Fetch data from cache when both billerIds and processorBillerIds are provided:
    @Test
    public void test_fetch_data_from_cache_with_both_ids() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = List.of(UUID.randomUUID());
        List<String> processorBillerIds = List.of("processorBillerId1");
        Map<String, Object> expectedCacheData = new HashMap<>();
        expectedCacheData.put(billerIds.get(0).toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());
        expectedCacheData.put(processorBillerIds.get(0) + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(expectedCacheData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedCacheData, result);
    }
..................................................................................
Fetch data from cache when only billerIds are provided:
    @Test
    public void test_fetch_data_from_cache_with_biller_ids_only() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = List.of(UUID.randomUUID());
        List<String> processorBillerIds = Collections.emptyList();
        Map<String, Object> expectedCacheData = new HashMap<>();
        expectedCacheData.put(billerIds.get(0).toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(expectedCacheData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedCacheData, result);
    }
..................................................................................
Fetch data from cache when only processorBillerIds are provided:
    @Test
    public void test_fetch_data_from_cache_with_processor_biller_ids_only() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = Collections.emptyList();
        List<String> processorBillerIds = List.of("processorBillerId1");
        Map<String, Object> expectedCacheData = new HashMap<>();
        expectedCacheData.put(processorBillerIds.get(0) + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(expectedCacheData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedCacheData, result);
    }
..................................................................................
Fetch data from DB when cache is empty for both billerIds and processorBillerIds:
    @Test
    public void test_fetch_data_from_db_when_cache_empty_for_both_ids() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = List.of(UUID.randomUUID());
        List<String> processorBillerIds = List.of("processorBillerId1");
        Map<String, Object> expectedDBData = new HashMap<>();
        expectedDBData.put(billerIds.get(0).toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());
        expectedDBData.put(processorBillerIds.get(0) + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(Collections.emptyMap());
        when(service.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds)).thenReturn(expectedDBData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedDBData, result);
    }
..................................................................................
Fetch data from DB when cache is empty for billerIds:
    @Test
    public void test_fetch_data_from_db_when_cache_empty_for_biller_ids() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = List.of(UUID.randomUUID());
        List<String> processorBillerIds = Collections.emptyList();
        Map<String, Object> expectedDBData = new HashMap<>();
        expectedDBData.put(billerIds.get(0).toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(Collections.emptyMap());
        when(service.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds)).thenReturn(expectedDBData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedDBData, result);
    }
..................................................................................
Fetch data from DB when cache is empty for processorBillerIds:
    @Test
    public void test_fetch_data_from_db_when_cache_empty_for_processor_biller_ids() {
        BillerCoreService service = new BillerCoreService();
        List<UUID> billerIds = Collections.emptyList();
        List<String> processorBillerIds = List.of("processorBillerId1");
        Map<String, Object> expectedDBData = new HashMap<>();
        expectedDBData.put(processorBillerIds.get(0) + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT, new Date());

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds)).thenReturn(Collections.emptyMap());
        when(service.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds)).thenReturn(expectedDBData);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(expectedDBData, result);
    }
..................................................................................
Handle null billerIds and processorBillerIds:
    @Test
    public void test_handle_null_both_ids() {
        BillerCoreService service = new BillerCoreService();
    
        Map<String, Object> expectedResult = Collections.emptyMap();

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(null, null)).thenReturn(expectedResult);
    
        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(null, null);

        assertEquals(expectedResult, result);
    }
..................................................................................
Handle empty billerIds and processorBillerIds:
    @Test
    public void test_handle_empty_both_ids() {
        BillerCoreService service = new BillerCoreService();
    
        Map<String, Object> expectedResult = Collections.emptyMap();

        when(service.fetchBillerDataLastUpdatedAtMapFromCache(Collections.emptyList(), Collections.emptyList())).thenReturn(expectedResult);
    
        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(Collections.emptyList(), Collections.emptyList());

        assertEquals(expectedResult, result);
    }
..................................................................................
Handle exceptions during cache fetch:
    @Test
    public void test_handle_exceptions_during_cache_fetch() {
        // Prepare
        Fetchbillerdatalastupdatedatmap fetchbillerdatalastupdatedatmap = new Fetchbillerdatalastupdatedatmap();
    
        // Define input
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("12345", "67890");
    
        // Execute and Assert
        assertThrows(Exception.class, () -> {
            fetchbillerdatalastupdatedatmap.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);
        });
    }
..................................................................................
Handle exceptions during DB fetch:
    @Test
    public void test_handle_exceptions_during_db_fetch() {
        // Prepare
        Fetchbillerdatalastupdatedatmap fetchbillerdatalastupdatedatmap = new Fetchbillerdatalastupdatedatmap();

        // Define input
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("12345", "67890");

        // Define expected output
        Map<String, Object> expectedOutput = new HashMap<>();

        // Perform the test
        Map<String, Object> result = fetchbillerdatalastupdatedatmap.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        // Verify the result
        assertEquals(expectedOutput, result);
    }
..................................................................................
Ensure cache keys are correctly formatted with suffix:
    @Test
    public void test_fetch_biller_data_last_updated_at_map() {
        // Prepare
        Fetchbillerdatalastupdatedatmap fetchbillerdatalastupdatedatmap = new Fetchbillerdatalastupdatedatmap();
    
        // Define input
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("12345", "67890");
    
        // Call the method
        Map<String, Object> result = fetchbillerdatalastupdatedatmap.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);
    
        // Assertions or verifications
        assertNotNull(result);
        // Add more assertions as needed
    }
..................................................................................
Ensure no duplicate entries in the final map:
    @Test
    public void test_no_duplicate_entries_in_final_map() {
        // Prepare
        Fetchbillerdatalastupdatedatmap fetchbillerdatalastupdatedatmap = new Fetchbillerdatalastupdatedatmap();
    
        // Define input data
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("12345", "67890");
    
        // Call the method under test
        Map<String, Object> result = fetchbillerdatalastupdatedatmap.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);
    
        // Validate
        Set<String> uniqueKeys = new HashSet<>();
        boolean hasDuplicates = result.keySet().stream()
            .anyMatch(key -> !uniqueKeys.add(key));
    
        assertFalse(hasDuplicates, "Duplicate entries found in the final map");
    }
..................................................................................
..................................................................................
Fetch biller data from cache when cache is not empty:
    @Test
    public void fetch_biller_data_from_cache_when_cache_is_not_empty() {
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123");
        Map<String, Object> cacheData = new HashMap<>();
        cacheData.put("123_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        BillerCoreService service = Mockito.spy(new BillerCoreService());
        Mockito.doReturn(cacheData).when(service).fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(cacheData, result);
    }
..................................................................................
Fetch biller data from database when cache is empty:
    @Test
    public void fetch_biller_data_from_db_when_cache_is_empty() {
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123");
        Map<String, Object> dbData = new HashMap<>();
        dbData.put("123_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        BillerCoreService service = Mockito.spy(new BillerCoreService());
        Mockito.doReturn(null).when(service).fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds);
        Mockito.doReturn(dbData).when(service).fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(dbData, result);
    }
..................................................................................
Combine cache and database results when some biller IDs are missing in cache:
    @Test
    public void combine_cache_and_db_results_when_some_biller_ids_missing_in_cache() {
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Collections.emptyList();
        Map<String, Object> cacheData = new HashMap<>();
        cacheData.put(billerIds.get(0).toString() + "_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        Map<String, Object> dbData = new HashMap<>();
        dbData.put(billerIds.get(1).toString() + "_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        BillerCoreService service = Mockito.spy(new BillerCoreService());
        Mockito.doReturn(cacheData).when(service).fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds);
        Mockito.doReturn(dbData).when(service).fetchBillerDataLastUpdatedAtMapFromDB(Mockito.anyList(), Mockito.isNull());

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(2, result.size());
    }
..................................................................................
Combine cache and database results when some processor biller IDs are missing in cache:
    @Test
    public void combine_cache_and_db_results_when_some_processor_biller_ids_missing_in_cache() {
        List<UUID> billerIds = Collections.emptyList();
        List<String> processorBillerIds = Arrays.asList("123", "456");
        Map<String, Object> cacheData = new HashMap<>();
        cacheData.put("123_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        Map<String, Object> dbData = new HashMap<>();
        dbData.put("456_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());

        BillerCoreService service = Mockito.spy(new BillerCoreService());
        Mockito.doReturn(cacheData).when(service).fetchBillerDataLastUpdatedAtMapFromCache(billerIds, processorBillerIds);
        Mockito.doReturn(dbData).when(service).fetchBillerDataLastUpdatedAtMapFromDB(Mockito.isNull(), Mockito.anyList());

        Map<String, Object> result = service.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        assertEquals(2, result.size());
    }
..................................................................................
Handle null or empty biller IDs and processor biller IDs lists:
    @Test
    public void test_fetch_biller_data_last_updated_at_map_with_null_and_empty_lists() {
        // Prepare
        List<UUID> billerIds = null;
        List<String> processorBillerIds = new ArrayList<>();

        // Execute
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        // Verify
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
..................................................................................
Handle exceptions when fetching biller data from database:
    @Test
    public void test_handle_exceptions_fetching_biller_data_from_database() {
        // Prepare
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123", "456");
    
        when(billerRepository.getBillersInfo(eq(billerIds), anyBoolean())).thenThrow(new RuntimeException("Database connection error"));
    
        // Execute
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);
    
        // Verify
        assertTrue(result.isEmpty());
    }
..................................................................................
Confirm that the method returns an empty map when both inputs are empty:
    @Test
    public void test_returns_empty_map_when_both_inputs_are_empty() {
        // Arrange
        List<UUID> emptyBillerIds = new ArrayList<>();
        List<String> emptyProcessorBillerIds = new ArrayList<>();

        // Act
        Map<String, Object> result = null;
        try {
            result = code_under_test.fetchBillerDataLastUpdatedAtMap(emptyBillerIds, emptyProcessorBillerIds);
        } catch (Exception e) {
            fail("Exception thrown during method execution: " + e.getMessage());
        }

        // Assert
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }
..................................................................................
Verify that the correct exception is thrown when database fetch fails:
    @Test
    public void test_database_fetch_failure_exception() {
        // Prepare
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123", "456");
    
        when(billerRepository.getBillersInfo(eq(billerIds), eq(false)))
            .thenThrow(new RuntimeException("Database fetch error"));
    
        when(billerRepository.getBillersInfo(eq(processorBillerIds), eq(false)))
            .thenThrow(new RuntimeException("Database fetch error"));
    
        // Verify & Assert
        assertThrows(ProcessingException.class, () -> {
            code_under_test.fetchBillerDataLastUpdatedAtMap(billerIds, null);
        });
    
        assertThrows(ProcessingException.class, () -> {
            code_under_test.fetchBillerDataLastUpdatedAtMap(null, processorBillerIds);
        });
    }
..................................................................................
Handle case when both biller IDs and processor biller IDs are empty:
    @Test
    public void test_handle_case_when_both_biller_ids_and_processor_biller_ids_are_empty() {
        // Prepare
        when(billerRepository.getBillersInfo(anyList(), anyBoolean())).thenReturn(Collections.emptyList());
    
        // Execute
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMap(Collections.emptyList(), Collections.emptyList());
    
        // Verify
        assertTrue(result.isEmpty());
        verify(billerRepository, times(1)).getBillersInfo(anyList(), anyBoolean());
    }
..................................................................................
Handle case when cache contains partial data for biller IDs:
    @Test
    public void test_handle_partial_data_in_cache_for_biller_ids() {
        // Prepare test data
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123", "456");

        // Mock behavior for fetchBillerDataLastUpdatedAtMapFromCache
        when(code_under_test.fetchBillerDataLastUpdatedAtMapFromCache(eq(billerIds), eq(processorBillerIds)))
                .thenReturn(new HashMap<>());

        // Mock behavior for fetchBillerDataLastUpdatedAtMapFromDB
        Map<String, Object> expectedMap = new HashMap<>();
        expectedMap.put("123_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());
        expectedMap.put("456_WPS_BILLER_DATA_UPDATED_AT", LocalDateTime.now());
        when(code_under_test.fetchBillerDataLastUpdatedAtMapFromDB(eq(billerIds), eq(processorBillerIds)))
                .thenReturn(expectedMap);

        // Call the method under test
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMap(billerIds, processorBillerIds);

        // Verify the result
        assertEquals(expectedMap, result);
    }
..................................................................................
..................................................................................
..................................................................................
..................................................................................

Manages scenarios where biller data cache operations fail:
    @Test
    public void test_reload_cache_for_biller_data_failure() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("12345");
    
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("12345");
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        doThrow(new RuntimeException("DB fetch error")).when(wmClient).delete(anyString());
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.contains("12345"));
        verify(wmClient, times(1)).delete(anyString());
    }
..................................................................................
Handles cases where biller data update timestamp cache operations fail:
    @Test
    public void test_reload_cache_for_biller_data_and_update_timestamp_data_failure() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDOs.add(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(wmClient.set(anyString(), anyInt(), any(Biller.class))).thenThrow(new RuntimeException("Cache write error"));
        when(wmClient.delete(anyString())).thenThrow(new RuntimeException("Cache delete error"));

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.contains("123"));
        verify(billerRepository, times(1)).getBillersInfo(anyList(), eq(true));
        verify(wmClient, times(1)).set(anyString(), anyInt(), any(Biller.class));
        verify(wmClient, times(1)).delete(anyString());
    }
    @Test
    public void test_reload_cache_for_biller_data_and_update_timestamp_data_failure_evict() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDOs.add(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(wmClient.set(anyString(), anyInt(), any(Biller.class))).thenThrow(new RuntimeException("Cache write error"));
        when(wmClient.delete(anyString())).thenThrow(new RuntimeException("Cache delete error"));

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.contains("123"));
        verify(billerRepository, times(1)).getBillersInfo(anyList(), eq(true));
        verify(wmClient, times(1)).set(anyString(), anyInt(), any(Biller.class));
        verify(wmClient, times(1)).delete(anyString());
    }
..................................................................................
Adds parent biller to cache if the parent is enabled:
    @Test
    public void test_adds_parent_biller_to_cache_if_enabled() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("12345");
    
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("12345");
        billerDO.setEnabled(true);
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
    
        List<BillerDO> subBillers = new ArrayList<>();
        BillerDO subBillerDO = new BillerDO();
        subBillerDO.setProcessorBillerId("54321");
        subBillers.add(subBillerDO);
    
        BillerDO parentBillerDO = new BillerDO();
        parentBillerDO.setProcessorBillerId("12345");
        parentBillerDO.setSubBillers(subBillers);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.singletonList(parentBillerDO));
    
        Biller biller = new Biller();
        biller.setProcessorBillerId("12345");
        biller.setEnabled(true);
    
        when(billerMapper.toBiller(any(BillerDO.class))).thenReturn(biller);
    
        when(wmClient.set(anyString(), anyInt(), any(Biller.class))).thenReturn(new OperationFuture<>());
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
    
        verify(wmClient, times(1)).set(eq("12345_WPS_BILLER_DATA"), anyInt(), eq(biller));
    }
..................................................................................
Handles cases where billers have null parent biller:
    @Test
    public void test_handle_null_parent_billers() {
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(BillPayUtil.isBillerHavingProducts(any(BillerDO.class))).thenReturn(false);
        when(BillPayUtil.isBillerAProduct(any(BillerDO.class))).thenReturn(false);

        Set<String> result = codeUnderTest.reloadCacheForBillerData(new HashSet<>(Arrays.asList("123", "456")));

        assertTrue(result.isEmpty());
        verify(BillPayUtil, times(2)).isBillerAProduct(any(BillerDO.class));
    }
..................................................................................
Deals with null or empty biller data returned from the repository:
    @Test
    public void test_handle_null_or_empty_biller_data() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(null);

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
        verify(billerRepository, times(1)).getBillersInfo(anyList(), eq(true));
    }
..................................................................................
Manages exceptions during biller data fetching from the repository:
    @Test
    public void test_handle_exceptions_during_biller_data_fetching() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenThrow(new RuntimeException());

        assertThrows(ProcessingException.class, () -> {
            codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        });
    }
..................................................................................
Handles empty processorBillerIds set gracefully:
    @Test
    public void test_handle_empty_processor_biller_ids() {
        Set<String> processorBillerIds = new HashSet<>();

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
        verify(billerRepository, never()).getBillersInfo(anyList(), eq(true));
    }
..................................................................................
Successfully reloads cache for billers and updates timestamp data:
    @Test
    public void test_reload_cache_and_update_timestamp() {
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(mock(OperationFuture.class));

        Set<String> result = codeUnderTest.reloadCacheForBillerAndUpdateTimestampData(billerDOs);

        assertTrue(result.isEmpty());
        verify(wmClient, times(4)).set(anyString(), anyInt(), any());
    }
..................................................................................
Accurately identifies billers to cache:
    @Test
    public void test_identify_billers_to_cache() {
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(BillPayUtil.isBillerHavingProducts(any(BillerDO.class))).thenReturn(false);
        when(BillPayUtil.isBillerAProduct(any(BillerDO.class))).thenReturn(true);

        Set<String> result = codeUnderTest.reloadCacheForBillerData(new HashSet<>(Arrays.asList("123", "456")));

        assertTrue(result.isEmpty());
        verify(BillPayUtil, times(2)).isBillerAProduct(any(BillerDO.class));
    }
..................................................................................
Properly evicts data from cache for billers not present in the database:
    @Test
    public void test_evict_data_from_cache() {
        List<String> processorBillerIdsToEvict = Arrays.asList("456");
        doNothing().when(wmClient).delete(anyString());

        codeUnderTest.evictDataFromCacheForBillersNotPresentInDB(processorBillerIdsToEvict);

        verify(wmClient, times(2)).delete(anyString());
    }
..................................................................................
Correctly identifies billers to evict from cache:
    @Test
    public void test_identify_billers_to_evict() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO("123"), new BillerDO("789"));
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);

        codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        verify(codeUnderTest, times(1)).evictDataFromCacheForBillersNotPresentInDB(Arrays.asList("456"));
    }
..................................................................................
Successfully fetches biller data from the repository:
    @Test
    public void test_fetch_biller_data_success() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
        verify(billerRepository, times(1)).getBillersInfo(anyList(), eq(true));
    }
..................................................................................
