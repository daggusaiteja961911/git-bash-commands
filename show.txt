458-460:

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully fetches biller incorrect search keywords from cache
    @Test
    public void test_fetch_biller_incorrect_search_keywords_from_cache() {
        WmClient wmClient = mock(WmClient.class);
        BillerCoreService billerCoreService = new BillerCoreService();
        ReflectionTestUtils.setField(billerCoreService, "wmClient", wmClient);
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(expectedMap);
        HashMap<String, List<String>> result = billerCoreService.fetchBillerIncorrectSearchKeywordMap();
        assertEquals(expectedMap, result);
    }

    // Successfully fetches biller incorrect search keywords from database if cache miss
    @Test
    public void test_fetch_biller_incorrect_search_keywords_from_db_if_cache_miss() {
        WmClient wmClient = mock(WmClient.class);
        BillerSearchRepository billerSearchRepository = mock(BillerSearchRepository.class);
        BillerCoreService billerCoreService = new BillerCoreService();
        ReflectionTestUtils.setField(billerCoreService, "wmClient", wmClient);
        ReflectionTestUtils.setField(billerCoreService, "billerSearchRepository", billerSearchRepository);
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);
        List<BillerSearchDO> billerSearchDOList = new ArrayList<>();
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchDOList);
        HashMap<String, List<String>> result = billerCoreService.fetchBillerIncorrectSearchKeywordMap();
        assertNotNull(result);
    }

    // Correctly logs information when fetching from cache
    @Test
    public void test_log_info_when_fetching_from_cache() {
        WmClient wmClient = mock(WmClient.class);
        BillerCoreService billerCoreService = new BillerCoreService();
        ReflectionTestUtils.setField(billerCoreService, "wmClient", wmClient);
        Logger logger = (Logger) LoggerFactory.getLogger(BillerCoreService.class);
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(new HashMap<>());
        billerCoreService.fetchBillerIncorrectSearchKeywordMap();
        List<ILoggingEvent> logsList = listAppender.list;
        assertTrue(logsList.stream().anyMatch(event -> event.getFormattedMessage().contains("Biller Incorrect Search Keywords from Cache")));
    }

    // Successfully caches biller incorrect search keywords after fetching from database
    @Test
    public void test_successfully_caches_biller_incorrect_search_keywords() {
        HashMap<String, List<String>> billerIncorrectSearchKeywordsMap = new HashMap<>();
        try {
            when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);
            when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(new ArrayList<>());

            CodeUnderTest code_under_test = new CodeUnderTest();
            HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

            verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), eq(0), any(HashMap.class));
            assertNotNull(result);
        } catch (Exception e) {
            fail("Exception thrown");
        }
    }

    // Successfully sets the cache with the fetched biller incorrect search keywords
    @Test
    public void test_successfully_sets_cache_with_fetched_biller_incorrect_search_keywords() {
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        // Mocking the behavior of fetching from cache
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);
    
        // Mocking the behavior of fetching from DB
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);
    
        // Mocking the behavior of setting cache
        when(wmClient.set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), any(HashMap.class))).thenReturn(new OperationFuture<Boolean>());
    
        // Call the method under test
        HashMap<String, List<String>> actualBillerIncorrectSearchKeywordsMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();
    
        // Assertions
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, actualBillerIncorrectSearchKeywordsMap);
    }

    // Cache fetch returns null
    @Test
    public void test_cache_fetch_returns_null() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        expectedMap.put("key1", Arrays.asList("value1", "value2"));
    
        when(wmClient.get(anyString())).thenReturn(null);
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(Arrays.asList(
            new BillerSearchDO("key1", Arrays.asList(new BillerDO("value1"), new BillerDO("value2")))
        ));
    
        HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();
    
        assertNull(result);
    
        verify(wmClient, times(1)).get(anyString());
        verify(billerSearchRepository, times(1)).getAllEnabledBillerSearchDO();
        verify(wmClient, times(1)).set(anyString(), anyInt(), any());
    }

    // Database fetch returns empty list
    @Test
    public void test_fetch_and_cache_biller_incorrect_search_keyword_map() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        try {
            String cacheKey = WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY;
            expectedMap = (HashMap<String, List<String>>) wmClient.get(cacheKey);
            log.info("Biller Incorrect Search Keywords from Cache : [{}]", expectedMap);
        } catch (Exception e) {
            log.info("Failed to read BillerIncorrectSearchKeywordsMap from meghacache", e);
        }
        if (Objects.isNull(expectedMap)) {
            log.info("Fetching BillerIncorrectSearchKeywordsMap from database");
            HashMap<String, List<String>> actualMap = fetchAndCacheBillerIncorrectSearchKeywordMap();
            assertEquals(expectedMap, actualMap);
        }
    }

    // Correctly maps biller search keywords to biller names
    @Test
    public void test_correctly_maps_biller_search_keywords_to_biller_names() {
        // Setup
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        BillerSearchDO billerSearchDO = new BillerSearchDO();
        billerSearchDO.setIncorrectKeyword("incorrect_keyword");
        List<BillerDO> billers = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setBillerName("Biller1");
        billers.add(billerDO);
        billerSearchDO.setBillers(billers);
        billerSearchKeywords.add(billerSearchDO);

        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);

        // Execute
        HashMap<String, List<String>> actualMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Verify
        assertEquals(expectedMap, actualMap);
        verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), eq(0), any(HashMap.class));
    }
    @Test
    public void test_fetchAndCacheBillerIncorrectSearchKeywordMap() {
        // Setup
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        BillerSearchDO billerSearchDO = new BillerSearchDO();
        billerSearchDO.setIncorrectKeyword("incorrect_keyword");
        List<BillerDO> billers = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setBillerName("Biller1");
        billers.add(billerDO);
        billerSearchDO.setBillers(billers);
        billerSearchKeywords.add(billerSearchDO);

        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);

        // Execute
        HashMap<String, List<String>> actualMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Verify
        assertEquals(expectedMap, actualMap);
        verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), eq(0), any(HashMap.class));
    }

    // Correctly logs information when fetching from database
    @Test
    public void test_correctly_logs_information_when_fetching_from_database() {
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        // Mocking the behavior of fetching from cache
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(expectedBillerIncorrectSearchKeywordsMap);

        // Mocking the behavior of fetching from database
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);

        // Mocking the behavior of setting cache
        OperationFuture<Boolean> operationFuture = mock(OperationFuture.class);
        when(wmClient.set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), eq(expectedBillerIncorrectSearchKeywordsMap))).thenReturn(operationFuture);

        // Call the method under test
        HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Verify the interactions
        verify(wmClient, times(1)).get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY);
        verify(billerSearchRepository, times(1)).getAllEnabledBillerSearchDO();
        verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), eq(expectedBillerIncorrectSearchKeywordsMap));

        // Assertions
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, result);
    }
    @Test
    public void test_correctly_logs_information_when_fetching_from_database() {
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        // Mocking the behavior of fetching from cache
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(expectedBillerIncorrectSearchKeywordsMap);

        // Mocking the behavior of fetching from database
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);

        // Mocking the behavior of setting cache
        OperationFuture<Boolean> operationFuture = mock(OperationFuture.class);
        when(wmClient.set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), eq(expectedBillerIncorrectSearchKeywordsMap))).thenReturn(operationFuture);

        // Call the method under test
        HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Verify the interactions
        verify(wmClient, times(1)).get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY);
        verify(billerSearchRepository, times(1)).getAllEnabledBillerSearchDO();
        verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), eq(expectedBillerIncorrectSearchKeywordsMap));

        // Assertions
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, result);
    }

    // Database fetch throws an exception
    @Test
    public void test_database_fetch_throws_exception() {
        HashMap<String, List<String>> billerIncorrectSearchKeywordsMap = new HashMap<>();
        when(wmClient.get(anyString())).thenThrow(new RuntimeException("Simulating database fetch exception"));

        try {
            billerIncorrectSearchKeywordsMap = billerCoreService.fetchAndCacheBillerIncorrectSearchKeywordMap();
        } catch (ProcessingException e) {
            assertEquals(ErrorConstants.IncorrectSearchBillerData.BILLER_SEARCH_DB_FETCH_ERROR, e.getErrorCode());
        }
    }

    // Cache fetch throws an exception
    @Test
    public void test_cache_fetch_throws_exception() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        expectedMap.put("key1", Arrays.asList("value1", "value2"));
    
        when(wmClient.get(anyString())).thenThrow(new RuntimeException("Cache fetch exception"));
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(Arrays.asList(
            new BillerSearchDO("key1", Arrays.asList(new BillerDO("value1"), new BillerDO("value2")))
        ));
    
        HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();
    
        assertEquals(expectedMap, result);
    }

    // Duplicate incorrect keywords in the database
    @Test
    public void test_duplicate_incorrect_keywords_in_database() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        List<String> billersList = new ArrayList<>();
        billersList.add("Biller1");
        billersList.add("Biller2");
        expectedMap.put("IncorrectKeyword1", billersList);

        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(Arrays.asList(
            new BillerSearchDO("IncorrectKeyword1", Arrays.asList(new BillerDO("Biller1"), new BillerDO("Biller2")))
        ));
        when(wmClient.set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), anyInt(), eq(expectedMap))).thenReturn(new OperationFuture<Boolean>());

        HashMap<String, List<String>> result = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        assertEquals(expectedMap, result);
    }

    // Biller search keywords have null biller names
    @Test
    public void test_biller_search_keywords_with_null_names() {
        // Setup
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        List<BillerSearchDO> mockBillerSearchKeywords = new ArrayList<>();
        BillerSearchDO mockBillerSearchDO = new BillerSearchDO();
        mockBillerSearchDO.setIncorrectKeyword("test_keyword");
        mockBillerSearchDO.setBillers(null);
        mockBillerSearchKeywords.add(mockBillerSearchDO);
    
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(mockBillerSearchKeywords);
    
        // Execute
        HashMap<String, List<String>> actualBillerIncorrectSearchKeywordsMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();
    
        // Verify
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, actualBillerIncorrectSearchKeywordsMap);
    }

    // Ensures thread safety during cache operations
    @Test
    public void test_ensures_thread_safety_during_cache_operations() {
        // Test logic for ensuring thread safety during cache operations
        // Simulate the scenario where the cache is accessed and updated by multiple threads
        // Verify that the cache operations are thread-safe
        ...
    }

    // Cache set operation fails
    @Test
    public void test_cache_set_operation_fails() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        expectedMap.put("key1", Arrays.asList("value1", "value2"));
    
        when(wmClient.get(anyString())).thenThrow(new RuntimeException("Cache read exception"));
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(Arrays.asList(
            new BillerSearchDO("key1", Arrays.asList(new BillerDO("value1"), new BillerDO("value2")))
        ));
        when(wmClient.set(anyString(), anyInt(), any())).thenThrow(new RuntimeException("Cache set exception"));
    
        HashMap<String, List<String>> result = billerCoreService.fetchAndCacheBillerIncorrectSearchKeywordMap();
    
        assertNull(result);
        verify(wmClient, times(1)).get(anyString());
        verify(billerSearchRepository, times(1)).getAllEnabledBillerSearchDO();
        verify(wmClient, times(1)).set(anyString(), anyInt(), any());
    }

    // Handles large datasets of biller search keywords efficiently
    @Test
    public void test_handles_large_datasets_of_biller_search_keywords_efficiently() {
        // Prepare
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        List<BillerSearchDO> billerSearchKeywords = new ArrayList<>();
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(billerSearchKeywords);

        // Execute
        HashMap<String, List<String>> actualBillerIncorrectSearchKeywordsMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Verify
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, actualBillerIncorrectSearchKeywordsMap);
        verify(wmClient, times(1)).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY), eq(0), eq(expectedBillerIncorrectSearchKeywordsMap));
    }

    // Validates the structure of the fetched data
    @Test
    public void test_fetch_and_cache_biller_incorrect_search_keyword_map() {
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        // Add expected data to the map

        // Mocking the behavior of wmClient.get(cacheKey)
        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);

        // Mocking the behavior of fetchAndCacheBillerIncorrectSearchKeywordMap()
        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(new ArrayList<>());

        // Call the method under test
        HashMap<String, List<String>> actualBillerIncorrectSearchKeywordsMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        // Assertions
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, actualBillerIncorrectSearchKeywordsMap);
    }

    // Ensures cache key consistency
    @Test
    public void test_ensures_cache_key_consistency() {
        HashMap<String, List<String>> expectedBillerIncorrectSearchKeywordsMap = new HashMap<>();
        expectedBillerIncorrectSearchKeywordsMap.put("key1", Arrays.asList("value1", "value2"));
        expectedBillerIncorrectSearchKeywordsMap.put("key2", Arrays.asList("value3", "value4"));

        // Mocking wmClient.get() to return null to simulate cache miss
        Mockito.when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenReturn(null);

        // Mocking fetchAndCacheBillerIncorrectSearchKeywordMap() to return expected map
        Mockito.when(code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap()).thenReturn(expectedBillerIncorrectSearchKeywordsMap);

        // Call the method under test
        HashMap<String, List<String>> actualBillerIncorrectSearchKeywordsMap = code_under_test.billerIncorrectSearchKeywordsMap;

        // Assertions
        assertNull(actualBillerIncorrectSearchKeywordsMap); // Ensure cache miss
        assertEquals(expectedBillerIncorrectSearchKeywordsMap, actualBillerIncorrectSearchKeywordsMap); // Ensure correct map is returned
    }
    }

    // Handles unexpected data formats gracefully
    @Test
    public void test_handles_unexpected_data_formats_gracefully() {
        HashMap<String, List<String>> expectedMap = new HashMap<>();
        expectedMap.put("key1", Arrays.asList("value1", "value2"));
        expectedMap.put("key2", Arrays.asList("value3", "value4"));

        when(wmClient.get(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORDS_MAP_CACHE_KEY)).thenThrow(new Exception("Cache miss"));

        when(billerSearchRepository.getAllEnabledBillerSearchDO()).thenReturn(Arrays.asList(
            new BillerSearchDO("key1", Arrays.asList(new BillerDO("value1"), new BillerDO("value2"))),
            new BillerSearchDO("key2", Arrays.asList(new BillerDO("value3"), new BillerDO("value4")))
        ));

        HashMap<String, List<String>> actualMap = code_under_test.fetchAndCacheBillerIncorrectSearchKeywordMap();

        assertEquals(expectedMap, actualMap);
    }

}
.................................................................................
348-361 & 384-400:

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully reload cache for biller data when valid processor biller IDs are provided
    @Test
    public void test_reload_cache_success() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());
        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Correctly identify and skip billers with products from caching
    @Test
    public void test_skip_billers_with_products() {
        BillerDO billerWithProducts = new BillerDO();
        when(BillPayUtil.isBillerHavingProducts(billerWithProducts)).thenReturn(true);
        List<BillerDO> billerDOs = Arrays.asList(billerWithProducts);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        Set<String> result = codeUnderTest.reloadCacheForBillerData(new HashSet<>(Arrays.asList("123")));
        assertTrue(result.isEmpty());
    }

    // Properly add billers to cache when they are products or have no enabled parent biller
    @Test
    public void test_add_billers_to_cache() {
        BillerDO productBiller = new BillerDO();
        when(BillPayUtil.isBillerAProduct(productBiller)).thenReturn(true);
        List<BillerDO> billerDOs = Arrays.asList(productBiller);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        Set<String> result = codeUnderTest.reloadCacheForBillerData(new HashSet<>(Arrays.asList("123")));
        assertFalse(result.isEmpty());
    }

    // Successfully update cache timestamps for billers
    @Test
    public void test_update_cache_timestamps() {
        BillerDO billerDO = new BillerDO();
        List<BillerDO> billerDOs = Arrays.asList(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());
        Set<String> result = codeUnderTest.reloadCacheForBillerData(new HashSet<>(Arrays.asList("123")));
        assertTrue(result.isEmpty());
    }

    // Correctly map BillerDO to Biller using BillerMapper
    @Test
    public void test_map_billerdo_to_biller() {
        BillerDO billerDO = new BillerDO();
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(billerDO)).thenReturn(biller);
        Biller result = codeUnderTest.prepareBillerFromDO(billerDO);
        assertNotNull(result);
    }

    // Handle empty set of processor biller IDs gracefully
    @Test
    public void test_handle_empty_processor_biller_ids_gracefully() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();

        // Act
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Assert
        assertTrue(retryProcessorBillerIds.isEmpty());
    }

    // Handle cases where billersToCache list is empty
    @Test
    public void test_reload_cache_for_biller_data_when_billers_to_cache_list_is_empty() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.emptyList());

        // Act
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, never()).set(anyString(), anyInt(), any());
    }

    // Ensure that the biller behaviour code is correctly set based on biller properties
    @Test
    public void test_reload_cache_for_biller_data() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.singletonList(billerDO));
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.emptyList());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(Collections.emptyList());
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BBC_1");

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }
    @Test
    public void test_reload_cache_for_biller_and_update_timestamp_data() {
        // Prepare
        List<BillerDO> billersToCache = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billersToCache.add(billerDO);
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.emptyList());
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BBC_1");

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerAndUpdateTimestampData(billersToCache);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }

}

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully reloads cache for valid biller data
    @Test
    public void test_reload_cache_for_valid_biller_data() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.isBillerHavingProducts(any())).thenReturn(false);
        when(BillPayUtil.isBillerAProduct(any())).thenReturn(true);
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(mock(OperationFuture.class));
        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Correctly identifies and skips billers with products from caching
    @Test
    public void test_skip_billers_with_products_from_caching() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123"));
        BillerDO billerDO = new BillerDO();
        List<BillerDO> billerDOs = Collections.singletonList(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.isBillerHavingProducts(any())).thenReturn(true);
        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Adds billers to cache if they are products or have no parent biller
    @Test
    public void test_add_billers_to_cache_if_products_or_no_parent_biller() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123"));
        BillerDO billerDO = new BillerDO();
        List<BillerDO> billerDOs = Collections.singletonList(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.isBillerHavingProducts(any())).thenReturn(false);
        when(BillPayUtil.isBillerAProduct(any())).thenReturn(true);
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(mock(OperationFuture.class));
        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Updates cache with biller data and timestamp
    @Test
    public void test_update_cache_with_biller_data_and_timestamp() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123"));
        BillerDO billerDO = new BillerDO();
        List<BillerDO> billerDOs = Collections.singletonList(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.isBillerHavingProducts(any())).thenReturn(false);
        when(BillPayUtil.isBillerAProduct(any())).thenReturn(true);
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(mock(OperationFuture.class));
        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Handles empty processorBillerIds set gracefully
    @Test
    public void test_reload_cache_for_biller_data_with_empty_processor_biller_ids() {
        // Setup
        Set<String> processorBillerIds = new HashSet<>();

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
    }

    // Deals with empty or null billerDO list from repository
    @Test
    public void test_reload_cache_for_empty_or_null_billerDO_list() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.emptyList());

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, never()).set(anyString(), anyInt(), any());
    }

    // Logs information about billers skipped from caching
    @Test
    public void test_logs_skipped_billers_caching() {
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        processorBillerIds.add("456");

        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Arrays.asList(billerDO1, billerDO2));

        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        verify(log, times(1)).info("Biller with billerId:[{}], processorBillerId:[{}] skipped from caching due to having products", billerDO1.getBillerId(), billerDO1.getProcessorBillerId());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
        verify(BillPayUtil, times(1)).filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString());
        verify(billerMapper, times(2)).mapBillerDOToBillerWithoutSubBillersAndBillPlans(any());
        verify(billerMapper, times(2)).mapBillPlans(any());
        verify(billerMapper, times(2)).mapSubBillerDOsToBillers(any());
        verify(BillPayUtil, times(2)).computeMaxUpdatedTimestampForBillerData(any());
        verify(BillPayUtil, times(2)).getBillerBehaviourCode(any());

        // Additional verification and assertions can be added as needed
    }

    // Returns retry processor biller IDs for failed cache operations
    @Test
    public void test_reload_cache_for_biller_data() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        List<BillerDO> billerDOs = Collections.singletonList(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.emptyList());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(Collections.emptyList());
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }
    @Test
    public void test_reload_cache_for_biller_and_update_timestamp_data() {
        // Prepare
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.emptyList());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(Collections.emptyList());
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerAndUpdateTimestampData(Collections.singletonList(billerDO));
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }

    // Validates biller behaviour code assignment
    @Test
    public void test_reload_cache_for_biller_data() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setBillerId("1");
        billerDO.setProcessorBillerId("123");
        billerDOs.add(billerDO);
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);

        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(new ArrayList<>());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BBC_1");

        // Act
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Assert
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }
    @Test
    public void test_reload_cache_for_biller_and_update_timestamp_data() {
        // Prepare
        List<BillerDO> billersToCache = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billersToCache.add(billerDO);

        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BBC_1");

        OperationFuture operationFuture = mock(OperationFuture.class);
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(operationFuture);

        // Act
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerAndUpdateTimestampData(billersToCache);

        // Assert
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
    }

}
..............................................
327:
@Test
    public void test_reload_incorrect_search_data_in_cache() {
        // Prepare
        Date expectedTimestamp = new Date();
        when(billerSearchRepository.getBillerIncorrectSearchDataUpdateTimestamp()).thenReturn(expectedTimestamp);
        OperationFuture<Boolean> operationFuture = mock(OperationFuture.class);
        when(wmClient.set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORD_MAP_UPDATED_AT_CACHE_KEY), eq(0), eq(expectedTimestamp))).thenReturn(operationFuture);

        // Execute
        code_under_test.reloadIncorrectSearchDataInCache();

        // Verify
        verify(billerSearchRepository).getBillerIncorrectSearchDataUpdateTimestamp();
        verify(wmClient).set(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORD_MAP_UPDATED_AT_CACHE_KEY, 0, expectedTimestamp);
        verify(operationFuture).addListener(any());
    }
    @Test
    public void test_reload_incorrect_search_data_in_cache_with_exception() {
        // Prepare
        doThrow(new RuntimeException("Simulating wmClient exception")).when(wmClient).set(anyString(), anyInt(), any());

        // Execute
        assertThrows(Exception.class, () -> billerCoreService.reloadIncorrectSearchDataInCache());

        // Verify
        verify(wmClient, times(1)).set(anyString(), anyInt(), any());
    }
    @Test
    public void test_reload_incorrect_search_data_in_cache_when_biller_search_data_update_timestamp_returns_null() {
        // Setup
        when(billerSearchRepository.getBillerIncorrectSearchDataUpdateTimestamp()).thenReturn(null);

        // Act
        code_under_test.reloadIncorrectSearchDataInCache();

        // Verify
        verify(wmClient, never()).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORD_MAP_UPDATED_AT_CACHE_KEY), anyInt(), any());
    }
    @Test
    public void test_reload_incorrect_search_data_in_cache_failure() {
        // Prepare
        when(billerSearchRepository.getBillerIncorrectSearchDataUpdateTimestamp()).thenThrow(new RuntimeException("Failed to fetch data"));

        // Execute
        assertThrows(Exception.class, () -> billerCoreService.reloadIncorrectSearchDataInCache());

        // Verify
        verify(wmClient, never()).set(eq(WPSConstants.Biller.BILLER_INCORRECT_SEARCH_KEYWORD_MAP_UPDATED_AT_CACHE_KEY), anyInt(), any());
    }
.............................................
