77-88:

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Fetch biller data from cache when cache keys are present
    @Test
    public void test_fetch_biller_data_from_cache_when_cache_keys_present() throws ApplicationException {
        String processorBillerId = "12345";
        String cacheKey = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA;
        Biller expectedBiller = new Biller();
        when(wmClient.get(cacheKey)).thenReturn(expectedBiller);

        Biller result = billerCoreService.fetchAndCacheBillerData(processorBillerId);

        assertEquals(expectedBiller, result);
        verify(wmClient, times(1)).get(cacheKey);
    }

    // Fetch biller data from database when cache keys are absent
    @Test
    public void test_fetch_biller_data_from_database_when_cache_keys_absent() throws ApplicationException {
        String processorBillerId = "12345";
        String cacheKey = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA;
        BillerDO billerDO = new BillerDO();
        Biller expectedBiller = new Biller();
        when(wmClient.get(cacheKey)).thenReturn(null);
        when(billerRepository.findByProcessorBillerId(processorBillerId)).thenReturn(billerDO);
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(billerDO)).thenReturn(expectedBiller);

        Biller result = billerCoreService.fetchAndCacheBillerData(processorBillerId);

        assertEquals(expectedBiller, result);
        verify(billerRepository, times(1)).findByProcessorBillerId(processorBillerId);
    }

    // Cache biller data and updated timestamp when fetched from database
    @Test
    public void test_cache_biller_data_and_updated_timestamp_when_fetched_from_database() throws ApplicationException {
        String processorBillerId = "12345";
        String cacheKey = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA;
        String cacheKeyUpdatedAt = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT;
        BillerDO billerDO = new BillerDO();
        Biller expectedBiller = new Biller();
        expectedBiller.setMaxUpdateTimestamp(LocalDateTime.now());
        when(wmClient.get(cacheKey)).thenReturn(null);
        when(billerRepository.findByProcessorBillerId(processorBillerId)).thenReturn(billerDO);
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(billerDO)).thenReturn(expectedBiller);

        billerCoreService.fetchAndCacheBillerData(processorBillerId);

        verify(wmClient, times(1)).set(eq(cacheKey), anyInt(), eq(expectedBiller));
        verify(wmClient, times(1)).set(eq(cacheKeyUpdatedAt), anyInt(), eq(expectedBiller.getMaxUpdateTimestamp()));
    }

    // Handle both UUID and processorBillerId for fetching and caching biller data
    @Test
    public void test_handle_both_uuid_and_processor_biller_id() {
        // Test logic to be added
    }

    // Handle null processorBillerId and billerId gracefully
    @Test
    public void test_handle_null_processor_biller_id_and_biller_id_gracefully() {
        // Prepare
        String processorBillerId = null;
        UUID billerId = null;

        // Execute
        Biller result = code_under_test.fetchAndCacheBillerData(billerId, processorBillerId);

        // Verify
        assertNull(result);
    }

    // Handle invalid UUID or processorBillerId formats
    @Test
    public void test_handle_invalid_uuid_or_processor_biller_id_formats() {
        // Prepare
        String invalidProcessorBillerId = "invalid_id";
    
        // Execute
        ApplicationException exception = assertThrows(ApplicationException.class, () -> {
            code_under_test.fetchAndCacheBillerData(invalidProcessorBillerId);
        });
    
        // Verify
        assertNotNull(exception);
    }

    // Handle concurrent cache updates
    @Test
    public void test_handle_concurrent_cache_updates() {
        // Test logic to be added
    }

    // Verify correct cache keys are generated based on UUID and processorBillerId
    @Test
    public void test_correct_cache_keys_generated() {
        // Prepare
        String processorBillerId = "12345";
        UUID billerId = UUID.randomUUID();
    
        // Execute
        Biller result = code_under_test.fetchAndCacheBillerData(billerId, processorBillerId);
    
        // Verify
        assertNotNull(result);
        // Verify cache keys based on UUID
        String expectedBillerDataCacheKeyUUID = billerId + WPSConstants.Biller.SUFFIX_BILLER_DATA;
        String expectedBillerDataUpdateAtCacheKeyUUID = billerId + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT;
        // Verify cache keys based on processorBillerId
        String expectedBillerDataCacheKey = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA;
        String expectedBillerDataUpdatedAtCacheKey = processorBillerId + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT;
    
        // Assertions
        assertEquals(expectedBillerDataCacheKeyUUID, "12345_WPS_BILLER_DATA");
        assertEquals(expectedBillerDataUpdateAtCacheKeyUUID, "12345_WPS_BILLER_DATA_UPDATED_AT");
        assertEquals(expectedBillerDataCacheKey, "12345_WPS_BILLER_DATA");
        assertEquals(expectedBillerDataUpdatedAtCacheKey, "12345_WPS_BILLER_DATA_UPDATED_AT");
    }

    // Ensure proper exception handling for ApplicationException
    @Test
    public void test_fetch_and_cache_biller_data_with_application_exception() {
        // Prepare
        String processorBillerId = "12345";
        UUID billerId = UUID.randomUUID();
        when(fetchBillerDataFromCache(anyString(), anyString())).thenReturn(null);
        when(getBillerDO(any(UUID.class), anyString())).thenThrow(new ApplicationException("Error fetching BillerDO"));

        // Verify & Assert
        assertThrows(ApplicationException.class, () -> {
            code_under_test.fetchAndCacheBillerData(billerId, processorBillerId);
        });
    }

}
**********
300-312:

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Fetch biller data last updated timestamps for given biller IDs
    @Test
    public void fetch_biller_data_last_updated_timestamps_for_given_biller_ids() {
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Collections.emptyList();
        BillerDO billerDO = new BillerDO();
        billerDO.setUpdateDate(LocalDateTime.now());
        when(billerRepository.getBillersInfo(billerIds, false)).thenReturn(Arrays.asList(billerDO));
        Map<String, Object> result = codeUnderTest.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
        assertFalse(result.isEmpty());
    }

    // Fetch biller data last updated timestamps for given processor biller IDs
    @Test
    public void fetch_biller_data_last_updated_timestamps_for_given_processor_biller_ids() {
        List<UUID> billerIds = Collections.emptyList();
        List<String> processorBillerIds = Arrays.asList("123", "456");
        BillerDO billerDO = new BillerDO();
        billerDO.setUpdateDate(LocalDateTime.now());
        when(billerRepository.getBillersInfo(processorBillerIds, false)).thenReturn(Arrays.asList(billerDO));
        Map<String, Object> result = codeUnderTest.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
        assertFalse(result.isEmpty());
    }

    // Return an empty map when both biller IDs and processor biller IDs are empty
    @Test
    public void return_empty_map_when_both_biller_ids_and_processor_biller_ids_are_empty() {
        List<UUID> billerIds = Collections.emptyList();
        List<String> processorBillerIds = Collections.emptyList();
        Map<String, Object> result = codeUnderTest.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Correctly compute the maximum updated timestamp for biller data
    @Test
    public void correctly_compute_maximum_updated_timestamp_for_biller_data() {
        BillerDO billerDO = new BillerDO();
        billerDO.setUpdateDate(LocalDateTime.now().minusDays(1));
        LocalDateTime result = BillPayUtil.computeMaxUpdatedTimestampForBillerData(billerDO);
        assertEquals(billerDO.getUpdateDate(), result);
    }

    // Successfully add biller data last updated timestamps to cache
    @Test
    public void successfully_add_biller_data_last_updated_timestamps_to_cache() {
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Collections.emptyList();
        BillerDO billerDO = new BillerDO();
        billerDO.setUpdateDate(LocalDateTime.now());
        when(billerRepository.getBillersInfo(billerIds, false)).thenReturn(Arrays.asList(billerDO));
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(mock(OperationFuture.class));
        Map<String, Object> result = codeUnderTest.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
        assertFalse(result.isEmpty());
    }

    // Handle null or empty biller IDs and processor biller IDs lists
    @Test
    public void handle_null_or_empty_biller_ids_and_processor_biller_ids_lists() {
        List<UUID> billerIds = null;
        List<String> processorBillerIds = null;
        Map<String, Object> result = codeUnderTest.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
        assertTrue(result.isEmpty());
    }

    // Handle null values in biller data objects
    @Test
    public void test_handle_null_values_in_biller_data_objects() {
        // Prepare
        List<UUID> billerIds = Arrays.asList(UUID.randomUUID(), UUID.randomUUID());
        List<String> processorBillerIds = Arrays.asList("123", "456");
        List<BillerDO> billerDOS = new ArrayList<>();
        BillerDO billerDO1 = new BillerDO();
        billerDO1.setBillerId(UUID.randomUUID());
        billerDO1.setUpdateDate(LocalDateTime.now());
        BillerDO billerDO2 = new BillerDO();
        billerDO2.setProcessorBillerId("123");
        billerDO2.setUpdateDate(LocalDateTime.now());
        billerDOS.add(billerDO1);
        billerDOS.add(billerDO2);
    
        when(billerRepository.getBillersInfo(eq(billerIds), eq(false))).thenReturn(billerDOS);
    
        // Execute
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);
    
        // Verify
        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.containsKey(billerDO1.getBillerId().toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT));
        assertTrue(result.containsKey(billerDO2.getProcessorBillerId() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT));
    }
    @Test
    public void test_handle_null_values_in_biller_data_objects_with_null_biller_ids() {
        // Prepare
        List<String> processorBillerIds = Arrays.asList("123", "456");
        List<BillerDO> billerDOS = new ArrayList<>();
        BillerDO billerDO1 = new BillerDO();
        billerDO1.setBillerId(UUID.randomUUID());
        billerDO1.setUpdateDate(LocalDateTime.now());
        BillerDO billerDO2 = new BillerDO();
        billerDO2.setProcessorBillerId("123");
        billerDO2.setUpdateDate(LocalDateTime.now());
        billerDOS.add(billerDO1);
        billerDOS.add(billerDO2);
    
        when(billerRepository.getBillersInfo(eq(processorBillerIds), eq(false))).thenReturn(billerDOS);
    
        // Execute
        Map<String, Object> result = code_under_test.fetchBillerDataLastUpdatedAtMapFromDB(null, processorBillerIds);
    
        // Verify
        assertNotNull(result);
        assertEquals(2, result.size());
        assertTrue(result.containsKey(billerDO1.getBillerId().toString() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT));
        assertTrue(result.containsKey(billerDO2.getProcessorBillerId() + WPSConstants.Biller.SUFFIX_BILLER_DATA_UPDATED_AT));
    }

    // Handle cases where biller data objects have no bill plans
    @Test
    public void test_handle_cases_where_biller_data_objects_have_no_bill_plans() {
        // Prepare
        List<UUID> billerIds = new ArrayList<>();
        List<String> processorBillerIds = new ArrayList<>();
        Map<String, Object> expectedBillerDataLastUpdateAtMap = new HashMap<>();

        // Mocking behavior for billerRepository
        when(billerRepository.getBillersInfo(anyList(), eq(false))).thenReturn(Collections.emptyList());

        // Mocking behavior for wmClient set operation
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture<>());

        // Execute
        Map<String, Object> actualBillerDataLastUpdateAtMap = code_under_test.fetchBillerDataLastUpdatedAtMapFromDB(billerIds, processorBillerIds);

        // Verify
        assertEquals(expectedBillerDataLastUpdateAtMap, actualBillerDataLastUpdateAtMap);
    }

}
*******************

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Reload cache with valid biller data
    @Test
    public void test_reload_cache_with_valid_biller_data() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Handle billers without products correctly
    @Test
    public void test_handle_billers_without_products_correctly() {
        BillerDO billerDO = new BillerDO();
        billerDO.setSubBillers(Collections.emptyList());
        billerDO.setSubBillerShownAsProduct(false);

        boolean result = codeUnderTest.isBillerHavingProducts(billerDO);

        assertFalse(result);
    }

    // Cache biller data and update timestamp
    @Test
    public void test_cache_biller_data_and_update_timestamp() {
        List<BillerDO> billersToCache = Arrays.asList(new BillerDO(), new BillerDO());
        when(wmClient.set(anyString(), eq(0), any())).thenReturn(mock(OperationFuture.class));
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());

        Set<String> result = codeUnderTest.reloadCacheForBillerAndUpdateTimestampData(billersToCache);

        assertTrue(result.isEmpty());
    }

    // Evict non-existent billers from cache
    @Test
    public void test_evict_non_existent_billers_from_cache() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Collections.emptyList();
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Map BillerDO to Biller correctly
    @Test
    public void test_map_billerdo_to_biller_correctly() {
        BillerDO billerDO = new BillerDO();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(new Biller());

        Biller result = codeUnderTest.prepareBillerFromDO(billerDO);

        assertNotNull(result);
    }

    // Handle empty processorBillerIds set
    @Test
    public void test_handle_empty_processorbillerids_set() {
        Set<String> processorBillerIds = Collections.emptySet();

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Handle null BillerDO objects
    @Test
    public void test_handle_null_billerdo_objects() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(null);

        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);

        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(wmClient, never()).set(anyString(), anyInt(), any());
    }

    // Retry caching for failed billers
    @Test
    public void test_retry_caching_for_failed_billers() {
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(new Biller());
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(new ArrayList<>());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BillerBehaviourCode");

        Set<String> result = code_under_test.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Ensure correct cache key generation
    @Test
    public void test_reload_cache_for_biller_data() {
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        processorBillerIds.add("456");

        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO1 = new BillerDO();
        billerDO1.setProcessorBillerId("123");
        billerDO1.setBillerId("1");
        billerDO1.setParentBiller(null);
        billerDO1.setSubBillers(new ArrayList<>());
        billerDO1.setSubBillerShownAsProduct(false);
        billerDOs.add(billerDO1);

        BillerDO billerDO2 = new BillerDO();
        billerDO2.setProcessorBillerId("456");
        billerDO2.setBillerId("2");
        billerDO2.setParentBiller(billerDO1);
        billerDO2.setSubBillers(new ArrayList<>());
        billerDO2.setSubBillerShownAsProduct(true);
        billerDOs.add(billerDO2);

        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);

        Set<String> retryProcessorBillerIds = new HashSet<>();
        retryProcessorBillerIds.add("456");

        List<OperationFuture> billerDataFutureList = new ArrayList<>();
        List<OperationFuture> billerDataUpdatedAtTimestampFutureList = new ArrayList<>();

        Biller biller1 = new Biller();
        biller1.setBillerId(UUID.randomUUID());
        biller1.setMaxUpdateTimestamp(LocalDateTime.now());
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller1);
    
        OperationFuture future1 = new OperationFuture();
        future1.setKey("123_WPS_BILLER_DATA");
        future1.setStatus(new OperationStatus(true, StatusCode.SUCCESS, "Success"));
        billerDataFutureList.add(future1);

        OperationFuture future2 = new OperationFuture();
        future2.setKey("123_WPS_BILLER_DATA_UPDATED_AT");
        future2.setStatus(new OperationStatus(false, StatusCode.ERR_NOT_FOUND, "Not found"));
        billerDataUpdatedAtTimestampFutureList.add(future2);

        OperationFuture future3 = new OperationFuture();
        future3.setKey("456_WPS_BILLER_DATA");
        future3.setStatus(new OperationStatus(false, StatusCode.ERR_NOT_FOUND, "Not found"));
        billerDataFutureList.add(future3);

        OperationFuture future4 = new OperationFuture();
        future4.setKey("456_WPS_BILLER_DATA_UPDATED_AT");
        future4.setStatus(new OperationStatus(true, StatusCode.SUCCESS, "Success"));
        billerDataUpdatedAtTimestampFutureList.add(future4);

        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(future1, future2, future3, future4);

        Set<String> result = code_under_test.reloadCacheForBillerData(processorBillerIds);

        assertEquals(retryProcessorBillerIds, result);
    }

}
.............

// Generated by CodiumAI

import com.walmart.international.wallet.payment.core.service.BillerCoreService;

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Reload cache for valid biller data
    @Test
    public void test_reload_cache_for_valid_biller_data() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        List<BillerDO> billerDOs = Arrays.asList(new BillerDO(), new BillerDO());
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());

        Set<String> result = codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Handle billers with products correctly
    @Test
    public void test_handle_billers_with_products_correctly() {
        BillerDO billerDO = new BillerDO();
        billerDO.setSubBillers(Arrays.asList(new BillerDO()));
        billerDO.setSubBillerShownAsProduct(true);
        when(BillPayUtil.isBillerHavingProducts(billerDO)).thenReturn(true);

        boolean result = codeUnderTest.isBillerHavingProducts(billerDO);

        assertTrue(result);
    }

    // Cache biller data and update timestamps
    @Test
    public void test_cache_biller_data_and_update_timestamps() {
        List<BillerDO> billersToCache = Arrays.asList(new BillerDO(), new BillerDO());
        when(wmClient.set(anyString(), eq(0), any())).thenReturn(mock(OperationFuture.class));
        when(BillPayUtil.filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString())).thenReturn(Collections.emptyList());

        Set<String> result = codeUnderTest.reloadCacheForBillerAndUpdateTimestampData(billersToCache);

        assertTrue(result.isEmpty());
    }

    // Map BillerDO to Biller correctly
    @Test
    public void test_map_biller_do_to_biller_correctly() {
        BillerDO billerDO = new BillerDO();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(billerDO)).thenReturn(new Biller());

        Biller result = codeUnderTest.prepareBillerFromDO(billerDO);

        assertNotNull(result);
    }

    // Retrieve biller information from repository
    @Test
    public void test_retrieve_biller_information_from_repository() {
        Set<String> processorBillerIds = new HashSet<>(Arrays.asList("123", "456"));
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.emptyList());

        codeUnderTest.reloadCacheForBillerData(processorBillerIds);

        verify(billerRepository, times(1)).getBillersInfo(anyList(), eq(true));
    }

    // Handle null or empty processorBillerIds input
    @Test
    public void test_handle_null_or_empty_processor_biller_ids_input() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
    }

    // Log information when biller has products
    @Test
    public void test_log_information_when_biller_has_products() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
    
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDO.setSubBillerShownAsProduct(true);
    
        List<BillerDO> billerDOs = new ArrayList<>();
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
    
        // Act
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
        verify(log).info("Biller with billerId:[{}], processorBillerId:[{}] skipped from caching due to having products", "123", "123");
    }

    // Handle billers with null sub-billers
    @Test
    public void test_handle_billers_with_null_sub_billers() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDO.setParentBiller(null);
        billerDO.setSubBillers(null);
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
    
        Biller biller = new Biller();
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(new ArrayList<>());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BillerBehaviourCode");
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
    
        verify(wmClient, times(1)).set(eq("123_WPS_BILLER_DATA"), eq(0), eq(biller));
        verify(wmClient, times(1)).set(eq("123_WPS_BILLER_DATA_UPDATED_AT"), eq(0), any(LocalDateTime.class));
    }

    // Handle billers with null update timestamps
    @Test
    public void test_handle_billers_with_null_update_timestamps() {
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDO.setParentBiller(null);
        billerDO.setSubBillers(new ArrayList<>());
        billerDO.setSubBillerShownAsProduct(false);
        billerDO.setUpdateDate(null);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(Collections.singletonList(billerDO));
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(new Biller());
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(new ArrayList<>());
        when(BillPayUtil.computeMaxUpdatedTimestampForBillerData(any())).thenReturn(LocalDateTime.now());
        when(BillPayUtil.getBillerBehaviourCode(any())).thenReturn("BBC_1");

        Set<String> result = code_under_test.reloadCacheForBillerData(processorBillerIds);

        assertTrue(result.isEmpty());
    }

    // Ensure correct cache key generation for biller timestamps
    @Test
    public void test_reload_cache_for_biller_data() {
        // Prepare
        Set<String> processorBillerIds = new HashSet<>();
        processorBillerIds.add("123");
        List<BillerDO> billerDOs = new ArrayList<>();
        BillerDO billerDO = new BillerDO();
        billerDO.setProcessorBillerId("123");
        billerDOs.add(billerDO);
    
        when(billerRepository.getBillersInfo(anyList(), eq(true))).thenReturn(billerDOs);
    
        Biller biller = new Biller();
        biller.setProcessorBillerId("123");
        biller.setMaxUpdateTimestamp(LocalDateTime.now());
    
        when(billerMapper.mapBillerDOToBillerWithoutSubBillersAndBillPlans(any())).thenReturn(biller);
        when(billerMapper.mapBillPlans(any())).thenReturn(new ArrayList<>());
        when(billerMapper.mapSubBillerDOsToBillers(any())).thenReturn(new ArrayList<>());
    
        when(wmClient.set(anyString(), anyInt(), any())).thenReturn(new OperationFuture());
    
        // Execute
        Set<String> retryProcessorBillerIds = code_under_test.reloadCacheForBillerData(processorBillerIds);
    
        // Verify
        assertTrue(retryProcessorBillerIds.isEmpty());
    
        verify(wmClient, times(2)).set(anyString(), anyInt(), any());
        verify(BillPayUtil, times(1)).filterBillersFailedToCache(anyList(), eq(CacheAction.WRITE), anyString());
    }

}