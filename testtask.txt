    @Test
    public void test_manage_unexpected_exceptions_during_cancel_process() {
        // Initialize necessary objects
        CoFTopupTransactionDO coFTopupTransactionDO = new CoFTopupTransactionDO();
        coFTopupTransactionDO.setCoFTopupTransactionId(UUID.randomUUID());

        // Mocking behavior
        when(paymentCoreService.cancel(any(CancelRequest.class))).thenThrow(new PaymentCoreServiceException("Error"));

        // Perform the test
        assertThrows(ProcessingException.class, () -> cancelCoFTopupCoreTransaction(coFTopupTransactionDO));
    }
...............................................
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully delete a customer bill account when valid IDs are provided
    @Test
    public void test_delete_customer_bill_account_success() {
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId))
            .thenReturn(customerBillAccountDO);

        CustomerBillAccount result = billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);

        assertNotNull(result);
        assertTrue(customerBillAccountDO.isDeleted());
        verify(customerBillAccountRepository).save(customerBillAccountDO);
    }

    // Retrieve all saved customer bill accounts for a given processorBillerId and customerAccountId
    @Test
    public void test_get_all_saved_customer_bill_accounts() throws ApplicationException {
        String processorBillerId = "testProcessorBillerId";
        UUID customerAccountId = UUID.randomUUID();
        BillerDO billerDO = new BillerDO();
        List<CustomerBillAccountDO> customerBillAccounts = new ArrayList<>();
        CustomerBillAccountDO accountDO = new CustomerBillAccountDO();
        accountDO.setSaved(true);
        accountDO.setDeleted(false);
        customerBillAccounts.add(accountDO);

        when(billerRepository.getByProcessorBillerIdAndEnabled(processorBillerId, true))
            .thenReturn(Optional.of(billerDO));
        when(customerBillAccountRepository.findByProcessorBillerIdInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(
            anyList(), eq(customerAccountId)))
            .thenReturn(customerBillAccounts);

        List<CustomerBillAccount> result = billCoreServiceImpl.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);

        assertNotNull(result);
        assertFalse(result.isEmpty());
    }

    // Retrieve saved customer bill accounts for a given billerId and customerAccountId
    @Test
    public void test_get_saved_customer_bill_accounts() throws ApplicationException {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        BillerDO billerDO = new BillerDO();
        List<CustomerBillAccountDO> customerBillAccounts = new ArrayList<>();
        CustomerBillAccountDO accountDO = new CustomerBillAccountDO();
        accountDO.setSaved(true);
        accountDO.setDeleted(false);
        customerBillAccounts.add(accountDO);

        when(billerRepository.getByBillerIdAndEnabled(billerId, true))
            .thenReturn(Optional.of(billerDO));
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(
            anyList(), eq(customerAccountId)))
            .thenReturn(customerBillAccounts);

        List<CustomerBillAccount> result = billCoreServiceImpl.getSavedCustomerBillAccounts(billerId, customerAccountId, null);

        assertNotNull(result);
        assertFalse(result.isEmpty());
    }

    // Update customer bill account as already paid and send reminders when valid data is provided
    @Test
    public void test_update_customer_bill_account_as_already_paid() throws ApplicationException {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());
    
        CustomerBillAccountDO accountDO = new CustomerBillAccountDO();
        accountDO.setSaved(true);
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(requestContext.getCustomerBillAccountId()))
            .thenReturn(accountDO);

        AlreadyPaidResponseContext responseContext = billCoreServiceImpl.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        assertNotNull(responseContext);
        verify(customerBillAccountRepository).save(accountDO);
    }

    // Update customer bill account due info and raise reminders when valid request context is provided
    @Test
    public void test_update_customer_bill_account_due_info() throws ApplicationException {
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("testProcessorBillAccountId");
    
        CustomerBillAccountDO accountDO = new CustomerBillAccountDO();
        accountDO.setSaved(true);
    
        when(customerBillAccountRepository.findByProcessorBillAccountId(requestContext.getProcessorBillAccountId()))
            .thenReturn(Collections.singletonList(accountDO));

        billCoreServiceImpl.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        verify(customerBillAccountRepository).saveAll(anyList());
    }

    // Attempt to delete a non-existent customer bill account
    @Test
    public void test_delete_non_existent_customer_bill_account() {
        UUID customerBillAccountId = UUID.randomUUID();
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId))
            .thenReturn(null);

        assertThrows(BusinessValidationException.class, () -> {
            billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, UUID.randomUUID());
        });
    }

    // Attempt to delete a customer bill account with mismatched customerAccountId
    @Test
    public void test_delete_customer_bill_account_with_mismatched_customer_account_id() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
    
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(UUID.randomUUID()); // Different customer account id
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);
    
        // Execute & Verify
        assertThrows(BusinessValidationException.class, () -> {
            code_under_test.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        });
    }

    // Attempt to delete a customer bill account that is already marked as deleted
    @Test
    public void test_delete_customer_bill_account_already_deleted() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO mockedCustomerBillAccountDO = new CustomerBillAccountDO();
        mockedCustomerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        mockedCustomerBillAccountDO.setCustomerAccountId(customerAccountId);
        mockedCustomerBillAccountDO.setDeleted(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(mockedCustomerBillAccountDO);

        // Execute
        BusinessValidationException exception = assertThrows(BusinessValidationException.class, () -> {
            code_under_test.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        });

        // Verify
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_ALREADY_DELETED, exception.getErrorCode());
        assertEquals("Customer bill account with customerBillAccountId[" + customerBillAccountId + "] is already deleted", exception.getMessage());
    }

    // Fetch saved customer bill accounts with a null processorBillerId
    @Test
    public void test_fetch_saved_customer_bill_accounts_with_null_processor_biller_id() {
        // Prepare
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456789";
    
        // Mocking behavior
        when(customerBillAccountRepository.findByProcessorBillerIdInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), eq(customerAccountId)))
                .thenReturn(Collections.emptyList());
    
        // Execute
        List<CustomerBillAccount> result = billCoreService.getAllSavedCustomerBillAccounts(null, customerAccountId, accountNumber);
    
        // Verify
        assertTrue(result.isEmpty());
    }

    // Update customer bill account with mismatched processorBillerId or accountNumber
    @Test
    public void test_update_customer_bill_account_with_mismatched_processor_biller_id_or_account_number() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
    
        // Perform
        BusinessValidationException exception = assertThrows(BusinessValidationException.class, () -> {
            code_under_test.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        });
    
        // Verify
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_CUSTOMER_ACCOUNT_ID_MISMATCH, exception.getErrorCode());
    }

    // Ensure that reminders are correctly raised or deleted based on biller type
    @Test
    public void test_reminders_raised_or_deleted_based_on_biller_type() {
        // Prepare test data
    
        // Mock necessary dependencies
    
        // Call the method to be tested
    
        // Validate the reminders raised or deleted based on biller type
    
        // Assert the expected behavior
    }

    // Log detailed information for each operation for debugging purposes
    @Test
    public void test_log_detailed_information_for_each_operation() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();

        // Execute
        try {
            code_under_test.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
            code_under_test.getAllSavedCustomerBillAccounts("processorBillerId", customerAccountId, "accountNumber");
            code_under_test.getSavedCustomerBillAccounts(UUID.randomUUID(), customerAccountId, "accountNumber");
            code_under_test.getCustomerBillAccountsByType(customerAccountId, Collections.singletonList(BillType.ALL), 10, 5, 3, Pageable.unpaged());
            code_under_test.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(new AlreadyPaidRequestContext());
            code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(new UpdateCustomerBillDueInfoRequestContext());
        } catch (Exception e) {
            fail("Exception thrown: " + e.getMessage());
        }

        // Verify
        // Assertions for logging can be added here
    }

    // Validate that the last paid date is not a future date
    @Test
    public void validate_last_paid_date_not_future_date() {
        // Prepare
        BillCoreServiceImpl billCoreService = new BillCoreServiceImpl();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setLastPaidDate(new Date());
    
        // Set a future date as the last paid date
        Date futureDate = DateUtils.addDays(new Date(), 1);
        customerBillAccountDO.setLastPaidDate(futureDate);
    
        // Execute & Verify
        assertThrows(BusinessValidationException.class, () -> {
            billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(new AlreadyPaidRequestContext());
        });
    }

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class DeletecustomerbillaccountTest {
    // Successfully delete a customer bill account when valid IDs are provided
    @Test
    public void test_successful_deletion_with_valid_ids() {
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId))
            .thenReturn(customerBillAccountDO);

        CustomerBillAccount result = billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);

        assertNotNull(result);
        assertTrue(customerBillAccountDO.isDeleted());
        assertFalse(customerBillAccountDO.isSaved());
    }

    // Return a mapped CustomerBillAccount object after successful deletion
    @Test
    public void test_return_mapped_object_after_deletion() {
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId))
            .thenReturn(customerBillAccountDO);
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccount(customerBillAccountDO))
            .thenReturn(new CustomerBillAccount());

        CustomerBillAccount result = billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);

        assertNotNull(result);
    }

    // Update the 'isDeleted' and 'isSaved' flags correctly in the database
    @Test
    public void test_update_flags_correctly_in_database() {
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId))
            .thenReturn(customerBillAccountDO);

        billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);

        verify(customerBillAccountRepository).save(customerBillAccountDO);
        assertTrue(customerBillAccountDO.isDeleted());
        assertFalse(customerBillAccountDO.isSaved());
    }

    // Handle null or non-existent customerBillAccountId by throwing a BusinessValidationException
    @Test
    public void test_handle_null_or_non_existent_customer_bill_account_id() {
        // Initialize
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        // Mocking
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(null);

        // Verify and Assert
        assertThrows(BusinessValidationException.class, () -> {
            // Call the method
            billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        });
    }

    // Handle mismatch between provided customerAccountId and the one associated with the bill account
    @Test
    public void test_handle_mismatch_customer_account_id() {
        // Initialize
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(UUID.randomUUID());
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);

        // Execute
        try {
            deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        } catch (BusinessValidationException e) {
            // Verify
            assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_CUSTOMER_ACCOUNT_ID_MISMATCH, e.getErrorCode());
            assertEquals("customerAccountID[" + customerBillAccountDO.getCustomerAccountId() + "] associated with customer bill account doesn't match with customerAccountId[" + customerAccountId + "] in request", e.getMessage());
        }
    }

    // Ensure the repository save operation is called with the updated entity
    @Test
    public void test_repository_save_called_with_updated_entity() {
        // Initialize
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);

        // Call the method
        try {
            billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        } catch (BusinessValidationException e) {
            // Do nothing
        }

        // Verify
        verify(customerBillAccountRepository, times(1)).save(customerBillAccountDO);
    }

    // Handle already deleted customer bill accounts by throwing a BusinessValidationException
    @Test
    public void test_handle_already_deleted_customer_bill_account() {
        // Initialize
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(true);
        customerBillAccountDO.setSaved(true);
    
        // Mocking repository
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);
    
        // Verify exception is thrown
        assertThrows(BusinessValidationException.class, () -> {
            // Call the method under test
            billCoreServiceImpl.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        });
    }

    // Verify that the correct exception messages are thrown for different validation failures
    @Test
    public void test_delete_customer_bill_account_validation_failures() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);

        // Test and Verify
        // 1. Record not found for customerBillAccountID
        UUID nonExistingCustomerBillAccountId = UUID.randomUUID();
        BusinessValidationException exception1 = assertThrows(BusinessValidationException.class, () -> billCoreService.deleteCustomerBillAccount(nonExistingCustomerBillAccountId, customerAccountId));
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_NOT_FOUND, exception1.getErrorCode());

        // 2. customerAccountID associated with customer bill account doesn't match with customerAccountId in request
        UUID differentCustomerAccountId = UUID.randomUUID();
        BusinessValidationException exception2 = assertThrows(BusinessValidationException.class, () -> billCoreService.deleteCustomerBillAccount(customerBillAccountId, differentCustomerAccountId));
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_CUSTOMER_ACCOUNT_ID_MISMATCH, exception2.getErrorCode());

        // 3. Customer bill account is already deleted
        customerBillAccountDO.setDeleted(true);
        BusinessValidationException exception3 = assertThrows(BusinessValidationException.class, () -> billCoreService.deleteCustomerBillAccount(customerBillAccountId, customerAccountId));
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_ALREADY_DELETED, exception3.getErrorCode());

        verify(customerBillAccountRepository, times(3)).save(any());
    }

    // Check that the method handles UUID format errors gracefully
    @Test
    public void test_handles_uuid_format_errors_gracefully() {
        // Prepare
        UUID invalidCustomerBillAccountId = UUID.randomUUID();
        UUID invalidCustomerAccountId = UUID.randomUUID();

        // Execute
        BusinessValidationException exception = assertThrows(BusinessValidationException.class, () -> {
            deleteCustomerBillAccount(invalidCustomerBillAccountId, invalidCustomerAccountId);
        });

        // Verify
        assertNotNull(exception);
        assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_NOT_FOUND, exception.getErrorCode());
    }

    // Confirm that the method does not modify the database if an exception is thrown
    @Test
    public void test_does_not_modify_database_on_exception() {
        // Initialize the necessary objects
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);
        doThrow(new BusinessValidationException("Error")).when(customerBillAccountRepository).save(any(CustomerBillAccountDO.class));

        // Perform the method call
        try {
            billCoreService.deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        } catch (BusinessValidationException e) {
            // Verify that the database was not modified
            verify(customerBillAccountRepository, never()).save(any(CustomerBillAccountDO.class));
        }
    }

    // Validate that the method logs appropriate messages for each validation failure
    @Test
    public void test_delete_customer_bill_account_logs_messages_for_validation_failures() {
        // Prepare
        UUID customerBillAccountId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(customerBillAccountId);
        customerBillAccountDO.setCustomerAccountId(customerAccountId);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setSaved(true);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId)).thenReturn(customerBillAccountDO);

        // Execute
        try {
            deleteCustomerBillAccount(customerBillAccountId, UUID.randomUUID());
        } catch (BusinessValidationException e) {
            // Verify
            verify(customerBillAccountRepository, times(1)).findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId);
            verify(customerBillAccountRepository, times(1)).save(customerBillAccountDO);
            assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_CUSTOMER_ACCOUNT_ID_MISMATCH, e.getErrorCode());
        }

        // Execute
        try {
            deleteCustomerBillAccount(customerBillAccountId, customerAccountId);
        } catch (BusinessValidationException e) {
            // Verify
            verify(customerBillAccountRepository, times(2)).findByCustomerBillAccountIdAndIsSavedTrue(customerBillAccountId);
            verify(customerBillAccountRepository, times(2)).save(customerBillAccountDO);
            assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_ALREADY_DELETED, e.getErrorCode());
        }

        // Execute
        try {
            deleteCustomerBillAccount(UUID.randomUUID(), customerAccountId);
        } catch (BusinessValidationException e) {
            // Verify
            verify(customerBillAccountRepository, times(3)).findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class));
            verify(customerBillAccountRepository, times(3)).save(customerBillAccountDO);
            assertEquals(ErrorConstants.DeleteCustomerBillAccount.CUSTOMER_BILL_ACCOUNT_NOT_FOUND, e.getErrorCode());
        }
    }
    // Add more test cases for full coverage if needed

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {


    // Retrieve all saved customer bill accounts when processorBillerId and customerAccountId are valid
    @Test
    public void test_retrieve_all_saved_customer_bill_accounts_valid_ids() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "validProcessorBillerId";
        List<CustomerBillAccount> result = service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
        assertNotNull(result);
        assertFalse(result.isEmpty());
    }

    // Successfully handle retrieval when accountNumber is provided
    @Test
    public void test_handle_retrieval_with_account_number() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "validProcessorBillerId";
        String accountNumber = "123456789";
        List<CustomerBillAccount> result = service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, accountNumber);
        assertNotNull(result);
        assertFalse(result.isEmpty());
    }

    // Correctly map CustomerBillAccountDO to CustomerBillAccount using the mapper
    @Test
    public void test_correct_mapping_of_customer_bill_account_do_to_customer_bill_account() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        CustomerBillAccount result = service.customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(customerBillAccountDO);
        assertNotNull(result);
    }

    // Return an empty list when no saved customer bill accounts are found
    @Test
    public void test_return_empty_list_when_no_saved_accounts_found() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "nonExistentProcessorBillerId";
        List<CustomerBillAccount> result = service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // Handle null processorBillerId by throwing DataValidationException
    @Test
    public void test_handle_null_processor_biller_id() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        assertThrows(DataValidationException.class, () -> {
            service.getAllSavedCustomerBillAccounts(null, customerAccountId, null);
        });
    }

    // Handle null accountNumber gracefully without errors
    @Test
    public void test_handle_null_account_number_gracefully() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "validProcessorBillerId";
        List<CustomerBillAccount> result = service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
        assertNotNull(result);
    }

    // Handle exceptions during database retrieval by throwing ProcessingException
    @Test
    public void test_handle_exceptions_during_database_retrieval() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "invalidProcessorBillerId";
        assertThrows(ProcessingException.class, () -> {
            service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
        });
    }

    // Ensure de-duplication logic works correctly when unique constraint is absent
    @Test
    public void test_de_duplication_logic_without_unique_constraint() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        List<CustomerBillAccountDO> duplicateList = Arrays.asList(new CustomerBillAccountDO(), new CustomerBillAccountDO());
        Collection<CustomerBillAccountDO> result = service.getDeDupedCBAEntries(duplicateList);
        assertEquals(1, result.size());
    }

    // Handle empty or null customerBillAccountDOList without errors
    @Test
    public void test_handle_empty_or_null_customer_bill_account_do_list() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        List<CustomerBillAccountDO> emptyList = Collections.emptyList();
        Collection<CustomerBillAccountDO> result = service.getDeDupedCBAEntries(emptyList);
        assertNotNull(result);
        assertTrue(result.isEmpty());
    }

    // Verify logging occurs for both retrieval scenarios (with and without accountNumber)
    @Test
    public void test_logging_for_retrieval_scenarios() {
        Logger logger = (Logger) LoggerFactory.getLogger(BillCoreServiceImpl.class);
        ListAppender<ILoggingEvent> listAppender = new ListAppender<>();
        listAppender.start();
        logger.addAppender(listAppender);

        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "validProcessorBillerId";

        service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
        service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, "123456789");

        List<ILoggingEvent> logsList = listAppender.list;
        assertTrue(logsList.stream().anyMatch(event -> event.getMessage().contains("Fetching all saved customer bill account entries")));
        assertTrue(logsList.stream().anyMatch(event -> event.getMessage().contains("Fetching saved customer bill account entries")));
    
        listAppender.stop();
    }

    // Ensure the method handles large datasets efficiently
    @Test
    public void test_handle_large_datasets_efficiently() {
        BillCoreServiceImpl service = new BillCoreServiceImpl();
        UUID customerAccountId = UUID.randomUUID();
        String processorBillerId = "validProcessorBillerId";
    
        // Simulate a large dataset by mocking the repository response with a large list.
    
        List<CustomerBillAccount> result = service.getAllSavedCustomerBillAccounts(processorBillerId, customerAccountId, null);
    
        // Assuming the mock returns a large list, check if the method completes without performance issues.
    
        assertNotNull(result);
    
        // Additional performance checks can be added here.
    
    }

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully updates customer bill account due information when all validations pass
    @Test
    public void test_update_due_info_success() {
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("validId");
        requestContext.setProcessorBillerId("validBillerId");
        requestContext.setAccountNumber("validAccountNumber");
        requestContext.setDueDate(new Date(System.currentTimeMillis() + 86400000)); // Tomorrow's date
        requestContext.setDueAmount(BigDecimal.valueOf(100));
        requestContext.setDueAmountCurrencyUnit("USD");

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setAccountNumber("validAccountNumber");
        customerBillAccountDO.setProcessorBillerId("validBillerId");

        when(customerBillAccountRepository.findByProcessorBillAccountId("validId"))
            .thenReturn(Collections.singletonList(customerBillAccountDO));

        billCoreServiceImpl.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

    // Correctly raises reminders for updated customer bill accounts with valid due amounts
    @Test
    public void test_raise_reminders_for_valid_due_amounts() {
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("validId");
        requestContext.setProcessorBillerId("validBillerId");
        requestContext.setAccountNumber("validAccountNumber");
        requestContext.setDueDate(new Date(System.currentTimeMillis() + 86400000)); // Tomorrow's date
        requestContext.setDueAmount(BigDecimal.valueOf(100));
        requestContext.setDueAmountCurrencyUnit("USD");

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setAccountNumber("validAccountNumber");
        customerBillAccountDO.setProcessorBillerId("validBillerId");

        when(customerBillAccountRepository.findByProcessorBillAccountId("validId"))
            .thenReturn(Collections.singletonList(customerBillAccountDO));

        billCoreServiceImpl.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        verify(billPayReminderService, times(1)).raiseS1BillerReminder(any(), any());
    }

    // Properly saves updated customer bill account details to the repository
    @Test
    public void test_save_updated_details_to_repository() {
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("validId");
        requestContext.setProcessorBillerId("validBillerId");
        requestContext.setAccountNumber("validAccountNumber");
        requestContext.setDueDate(new Date(System.currentTimeMillis() + 86400000)); // Tomorrow's date

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setAccountNumber("validAccountNumber");
        customerBillAccountDO.setProcessorBillerId("validBillerId");

        when(customerBillAccountRepository.findByProcessorBillAccountId("validId"))
            .thenReturn(Collections.singletonList(customerBillAccountDO));

        billCoreServiceImpl.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

    // Validates and processes multiple customer bill accounts in a single request
    @Test
    public void test_process_multiple_accounts_in_request() {
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("validId");
        requestContext.setProcessorBillerId("validBillerId");
        requestContext.setAccountNumber("validAccountNumber");
        requestContext.setDueDate(new Date(System.currentTimeMillis() + 86400000)); // Tomorrow's date

        CustomerBillAccountDO account1 = new CustomerBillAccountDO();
        account1.setSaved(true);
        account1.setDeleted(false);
        account1.setAccountNumber("validAccountNumber");
        account1.setProcessorBillerId("validBillerId");

        CustomerBillAccountDO account2 = new CustomerBillAccountDO();
        account2.setSaved(true);
        account2.setDeleted(false);
        account2.setAccountNumber("validAccountNumber");
        account2.setProcessorBillerId("validBillerId");

        when(customerBillAccountRepository.findByProcessorBillAccountId("validId"))
            .thenReturn(Arrays.asList(account1, account2));

        billCoreServiceImpl.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

    // Logs information about the update process for traceability
    @Test
    public void test_logs_information_about_update_process_for_traceability() {
        // Prepare
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
    
        // Execute
        code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);
    
        // Verify
        // Add verification here
    
        // Assert
        // Add assertions here
    }

    // Manages cases where all customer bill accounts fail business validation
    @Test
    public void test_all_customer_bill_accounts_fail_business_validation() {
        // Prepare test data
    
        // Mock necessary dependencies
    
        // Call the method to be tested
    
        // Assert the results
    }

    // Handles null or empty processorBillAccountId in the request context
    @Test
    public void test_handles_null_or_empty_processor_bill_account_id() {
        // Prepare
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
    
        // Set null processorBillAccountId
        requestContext.setProcessorBillAccountId(null);
        assertThrows(DataValidationException.class, () -> {
            // Execute
            code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);
        });
    
        // Set empty processorBillAccountId
        requestContext.setProcessorBillAccountId("");
        assertThrows(DataValidationException.class, () -> {
            // Execute
            code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);
        });
    }

    // Handles exceptions during reminder event raising gracefully
    @Test
    public void test_handles_exceptions_during_reminder_event_raising_gracefully() {
        // Prepare test data
    
        // Mock dependencies
    
        // Set up expectations
    
        // Call the method under test
    
        // Verify the results and behavior
    
        // Handle exceptions gracefully
    }

    // Validates processorBillerId and accountNumber for consistency between request and database
    @Test
    public void test_update_customer_bill_account_due_info_and_raise_reminders() {
        // Prepare test data
    
        // Mock dependencies
    
        // Define expected behavior
    
        // Call the method to test
    
        // Validate the results
    }

    // Deals with duplicate due dates in the request context
    @Test
    public void test_deals_with_duplicate_due_dates() {
        // Prepare
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("12345");
        requestContext.setProcessorBillerId("67890");
        requestContext.setAccountNumber("98765");
        requestContext.setDueDate(new Date());
        requestContext.setDueAmount(BigDecimal.TEN);
        requestContext.setDueAmountCurrencyUnit("USD");
        requestContext.setDueInfoUpdatedBy("John Doe");

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setAccountNumber("98765");
        customerBillAccountDO.setProcessorBillerId("67890");
        customerBillAccountDO.setDueDate(new Date());
        customerBillAccountDO.setDueAmount(BigDecimal.TEN);
        customerBillAccountDO.setDueAmountCurrencyUnit(CurrencyUnit.USD);
        customerBillAccountDO.setDueInfoUpdatedBy("Jane Smith");

        List<CustomerBillAccountDO> savedCustomerBillAccountDOList = new ArrayList<>();
        savedCustomerBillAccountDOList.add(customerBillAccountDO);

        when(customerBillAccountRepository.findByProcessorBillAccountId("12345")).thenReturn(savedCustomerBillAccountDOList);

        // Execute
        code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        // Verify
        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

    // Processes requests with null or zero due amounts appropriately
    @Test
    public void test_processes_requests_with_null_or_zero_due_amounts_appropriately() {
        // Test setup
    
        // Create a mock UpdateCustomerBillDueInfoRequestContext with null or zero due amounts
    
        // Mock the behavior of fetchSavedCustomerBillAccountDOListUsingProcessorBillAccountId to return a list of CustomerBillAccountDO
    
        // Mock the behavior of customerBillAccountUpdateBusinessValidation to handle the validation
    
        // Mock the behavior of updateCustomerBillAccountDetails to update the due date and amount
    
        // Mock the behavior of raiseReminderEventForCustomerBillAccount to handle the reminder event
    
        // Call the method under test
    
        // Verify the appropriate interactions and assertions
    }

    // Filters out deleted or unsaved customer bill accounts from processing
    @Test
    public void test_filters_out_deleted_or_unsaved_customer_bill_accounts() {
        // Prepare test data
    
        // Call the method to be tested
    
        // Validate the results
    
        // Assert the expected behavior
    }

    // Logs errors and exceptions for failed operations
    @Test
    public void test_logs_errors_and_exceptions_for_failed_operations() {
        // Prepare
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("12345");
        requestContext.setProcessorBillerId("67890");
        requestContext.setAccountNumber("98765");
        requestContext.setDueDate(new Date());
    
        // Mocking
        when(customerBillAccountRepository.findByProcessorBillAccountId(anyString())).thenReturn(Arrays.asList(new CustomerBillAccountDO()));
    
        // Execute
        code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);
    
        // Verify
        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

    // Updates due information only when necessary fields are present
    @Test
    public void test_updates_due_info_when_necessary_fields_present() {
        // Prepare test data
        UpdateCustomerBillDueInfoRequestContext requestContext = new UpdateCustomerBillDueInfoRequestContext();
        requestContext.setProcessorBillAccountId("123");
        requestContext.setProcessorBillerId("456");
        requestContext.setAccountNumber("789");
        requestContext.setDueDate(new Date());
        requestContext.setDueAmount(BigDecimal.TEN);
        requestContext.setDueAmountCurrencyUnit("USD");
        requestContext.setDueInfoUpdatedBy("user123");

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setAccountNumber("789");
        customerBillAccountDO.setProcessorBillerId("456");
        customerBillAccountDO.setDueDate(new Date());
        customerBillAccountDO.setDueAmount(BigDecimal.ONE);
        customerBillAccountDO.setDueAmountCurrencyUnit(CurrencyUnit.USD);
        customerBillAccountDO.setDueInfoUpdatedBy("user456");

        List<CustomerBillAccountDO> savedCustomerBillAccountDOList = Collections.singletonList(customerBillAccountDO);

        // Mock dependencies and behavior
        when(customerBillAccountRepository.findByProcessorBillAccountId(anyString())).thenReturn(savedCustomerBillAccountDOList);

        // Call the method
        code_under_test.updateCustomerBillAccountDueInfoAndRaiseReminders(requestContext);

        // Verify the interactions
        verify(customerBillAccountRepository, times(1)).saveAll(anyList());
    }

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Successfully update a customer bill account as already paid when valid data is provided
    @Test
    public void test_update_customer_bill_account_as_already_paid_success() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());
        requestContext.setLastPaidDate(new Date());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        AlreadyPaidResponseContext response = billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        assertNotNull(response);
        assertNotNull(response.getCustomerBillAccount());
    }

    // Correctly send reminders after marking a bill account as already paid
    @Test
    public void test_send_reminders_after_marking_as_already_paid() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        verify(billPayReminderService, times(1)).raiseDeleteBillPayReminderEvent(any(CustomerBillAccount.class));
    }

    // Properly handle POSTPAID biller type by setting due date to null and updating due info
    @Test
    public void test_handle_postpaid_biller_type() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        CustomerBillAccount customerBillAccount = new CustomerBillAccount();
        customerBillAccount.setBiller(new Biller());
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class)))
            .thenReturn(customerBillAccount);

        billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        assertNull(customerBillAccount.getDueDate());
    }

    // Correctly handle PREPAID biller type by setting due date to top-up expiry date and sending reminders
    @Test
    public void test_handle_prepaid_biller_type() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        CustomerBillAccount customerBillAccount = new CustomerBillAccount();
        Biller biller = new Biller();
        biller.setCanCheckBalance(false);
        customerBillAccount.setBiller(biller);
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class)))
            .thenReturn(customerBillAccount);

        billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        assertNotNull(customerBillAccount.getDueDate());
    }

    // Handle OTHER biller type by setting due date to null and sending appropriate reminders
    @Test
    public void test_handle_other_biller_type() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        CustomerBillAccount customerBillAccount = new CustomerBillAccount();
        Biller biller = new Biller();
        biller.setCanCheckBalance(false);
        customerBillAccount.setBiller(biller);
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class)))
            .thenReturn(customerBillAccount);

        billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        assertNull(customerBillAccount.getDueDate());
    }

    // Handle null last paid date without throwing an exception
    @Test
    public void test_handle_null_last_paid_date() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        assertDoesNotThrow(() -> billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext));
    }

    // Throw an exception when the last paid date is in the future
    @Test
    public void test_throw_exception_for_future_last_paid_date() {
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());
        requestContext.setLastPaidDate(new Date(System.currentTimeMillis() + 86400000)); // Future date

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setSaved(true);
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class)))
            .thenReturn(customerBillAccountDO);

        assertThrows(BusinessValidationException.class, () -> 
            billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext));
    }

    // Handle cases where the customer bill account is not found in the repository
    @Test
    public void test_customer_bill_account_not_found_in_repository() {
        // Setup
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class))).thenReturn(null);

        // Verify
        assertThrows(ProcessingException.class, () -> {
            code_under_test.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);
        });
    }

    // Validate that the correct reminder subcategory is raised based on nudge count
    @Test
    public void test_correct_reminder_subcategory_based_on_nudge_count() {
        // Prepare test data
    
        // Mock necessary dependencies
    
        // Call the method under test
    
        // Validate the correct reminder subcategory is raised based on nudge count
    
        // Assert
    }

    // Correctly process when bill plans are empty or null
    @Test
    public void test_correctly_process_when_bill_plans_are_empty_or_null() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setLastPaidDate(new Date());
    
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(UUID.randomUUID());
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setProcessorBillAccountId("12345");
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class))).thenReturn(customerBillAccountDO);
    
        CustomerBillAccount customerBillAccount = new CustomerBillAccount();
        customerBillAccount.setCustomerBillAccountId(customerBillAccountDO.getCustomerBillAccountId());
        customerBillAccount.setCustomerAccountId(UUID.randomUUID());
        customerBillAccount.setBiller(new Biller());
        customerBillAccount.setProcessorBillAccountId(customerBillAccountDO.getProcessorBillAccountId());
        customerBillAccount.setLastPaidDateValue(new Date());
    
        BillDetail billDetail = new BillDetail();
        billDetail.setAmount(BigDecimal.TEN);
    
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class))).thenReturn(customerBillAccount);
        when(billPayReminderHelper.getTopUpExpiryDate(any(BillDetail.class), any(Date.class))).thenReturn(new Date());
        when(billerMapper.mapBillPlans(any(BillerDO.class))).thenReturn(Collections.emptyList());
    
        // Act
        AlreadyPaidResponseContext response = code_under_test.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);
    
        // Verify
        assertNotNull(response);
        verify(customerBillAccountRepository, times(1)).findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class));
        verify(customerBillAccountMapper, times(1)).customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class));
        verify(billPayReminderHelper, times(1)).getTopUpExpiryDate(any(BillDetail.class), any(Date.class));
        verify(billerMapper, times(1)).mapBillPlans(any(BillerDO.class));
    }

    // Handle null or empty biller display name when checking for consumption-based biller
    @Test
    public void test_handle_null_or_empty_biller_display_name() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setLastPaidDate(new Date());
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(UUID.randomUUID());
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setProcessorBillAccountId("processor_bill_account_id");
        customerBillAccountDO.setDueDate(new Date());
        customerBillAccountDO.setLastPaidDateValue(new Date());
        customerBillAccountDO.setBillerDO(new BillerDO());
        customerBillAccountDO.getBillerDO().setProcessorBillerId("processor_biller_id");
        customerBillAccountDO.getBillerDO().setDisplayName("");
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class))).thenReturn(customerBillAccountDO);
    
        // Execute
        AlreadyPaidResponseContext response = billCoreServiceImpl.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);
    
        // Verify
        assertNull(response);
        verify(billPayReminderService, times(1)).raiseDeleteBillPayReminderEvent(any(CustomerBillAccount.class), any(ReminderSubCategoryType.class));
    }
    @Test
    public void test_handle_null_or_empty_biller_display_name_empty_display_name() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setLastPaidDate(new Date());
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(UUID.randomUUID());
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setProcessorBillAccountId("processor_bill_account_id");
        customerBillAccountDO.setDueDate(new Date());
        customerBillAccountDO.setLastPaidDateValue(new Date());
        customerBillAccountDO.setBillerDO(new BillerDO());
        customerBillAccountDO.getBillerDO().setProcessorBillerId("processor_biller_id");
        customerBillAccountDO.getBillerDO().setDisplayName(null);
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class))).thenReturn(customerBillAccountDO);
    
        // Execute
        AlreadyPaidResponseContext response = billCoreServiceImpl.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);
    
        // Verify
        assertNull(response);
        verify(billPayReminderService, times(1)).raiseDeleteBillPayReminderEvent(any(CustomerBillAccount.class), any(ReminderSubCategoryType.class));
    }

    // Ensure that the bill detail is fetched correctly based on the last paid amount
    @Test
    public void ensure_bill_detail_fetched_correctly_based_on_last_paid_amount() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setLastPaidDate(new Date());
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(requestContext.getCustomerBillAccountId());
        customerBillAccountDO.setCustomerAccountId(requestContext.getCustomerAccountId());
        customerBillAccountDO.setLastPaidDateValue(new Date());

        BillDetail billDetail = new BillDetail();
        billDetail.setAmount(BigDecimal.TEN);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(requestContext.getCustomerBillAccountId())).thenReturn(customerBillAccountDO);
        when(billPayReminderHelper.getTopUpExpiryDate(any(), any())).thenReturn(new Date());
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.singletonList(new BillPlan()));
        when(billPayReminderService.raiseDeleteBillPayReminderEvent(any())).thenReturn(true);

        // Execute
        AlreadyPaidResponseContext response = code_under_test.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        // Verify
        assertNotNull(response);
        assertNotNull(response.getCustomerBillAccount());
    }

    // Confirm that the customer details are fetched correctly using the customer account ID
    @Test
    public void confirm_customer_details_fetched_correctly() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setCustomerBillAccountId(UUID.randomUUID());
        requestContext.setCustomerAccountId(UUID.randomUUID());
        requestContext.setLastPaidDate(new Date());

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(requestContext.getCustomerBillAccountId());
        customerBillAccountDO.setCustomerAccountId(requestContext.getCustomerAccountId());
        customerBillAccountDO.setLastPaidDateValue(new Date());

        BillDetail billDetail = new BillDetail();
        billDetail.setAmount(BigDecimal.TEN);

        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(requestContext.getCustomerBillAccountId())).thenReturn(customerBillAccountDO);
        when(billPayReminderHelper.getTopUpExpiryDate(any(), any())).thenReturn(new Date());
        when(billerMapper.mapBillPlans(any())).thenReturn(Collections.singletonList(new BillPlan()));
        when(customerServiceClientForEWS.getCustomerBasicDetailsById(any())).thenReturn(new CustomerBasicResponse());
        when(customerMapper.mapCustomerFromBasicDTOToContext(any())).thenReturn(new Customer());

        // Execute
        AlreadyPaidResponseContext response = code_under_test.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);

        // Verify
        assertNotNull(response);
        verify(customerBillAccountRepository, times(1)).findByCustomerBillAccountIdAndIsSavedTrue(requestContext.getCustomerBillAccountId());
        verify(billPayReminderHelper, times(1)).getTopUpExpiryDate(any(), any());
        verify(billerMapper, times(1)).mapBillPlans(any());
        verify(customerServiceClientForEWS, times(1)).getCustomerBasicDetailsById(any());
        verify(customerMapper, times(1)).mapCustomerFromBasicDTOToContext(any());
    }
    // Add more verification as needed

    // Verify that the correct biller type is determined based on balance check capability and expiry date
    @Test
    public void test_correct_biller_type_determined() {
        // Prepare
        AlreadyPaidRequestContext requestContext = new AlreadyPaidRequestContext();
        requestContext.setLastPaidDate(new Date());
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setCustomerBillAccountId(UUID.randomUUID());
        customerBillAccountDO.setSaved(true);
        customerBillAccountDO.setDeleted(false);
        customerBillAccountDO.setProcessorBillAccountId("12345");
        customerBillAccountDO.setDueDate(new Date());
        customerBillAccountDO.setLastPaidDateValue(new Date());
        customerBillAccountDO.setBillerDO(new BillerDO());
    
        when(customerBillAccountRepository.findByCustomerBillAccountIdAndIsSavedTrue(any(UUID.class))).thenReturn(customerBillAccountDO);
        when(billReminderConfiguration.getDaysOfMonthForBillPaymentNudge()).thenReturn("1,15,30");
        when(billReminderConfiguration.getReminderDaysCountForBillpayNudge()).thenReturn(3);
    
        // Act
        AlreadyPaidResponseContext response = billCoreService.updateCustomerBillAccountAsAlreadyPaidAndSendReminders(requestContext);
    
        // Assert
        assertNotNull(response);
        // Add more assertions as needed
    }
    // Add necessary imports and setup/teardown methods if required

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Retrieves customer bill accounts by type based on given criteria
    @Test
    public void test_retrieves_customer_bill_accounts_by_type() {
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.DUE, BillType.OVERDUE);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 10;
        int minDaysForNudge = 5;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountsByType result = billCoreServiceImpl.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        assertNotNull(result);
    }

    // Correctly categorizes bill accounts into overdue, due, and paid
    @Test
    public void test_categorizes_bill_accounts_correctly() {
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.ALL);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 10;
        int minDaysForNudge = 5;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountsByType result = billCoreServiceImpl.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        assertTrue(result.getOverdueBills().size() > 0 || result.getDueBills().size() > 0 || result.getPaidBills().size() > 0);
    }

    // Utilizes the nudge bucket to determine due status
    @Test
    public void test_utilizes_nudge_bucket_for_due_status() {
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.DUE);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 10;
        int minDaysForNudge = 5;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountsByType result = billCoreServiceImpl.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        assertNotNull(result.getDueBills());
    }

    // Sorts the categorized bill accounts correctly
    @Test
    public void test_sorts_categorized_bill_accounts() {
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.ALL);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 10;
        int minDaysForNudge = 5;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountsByType result = billCoreServiceImpl.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        assertTrue(result.getOverdueBills().isEmpty() || result.getOverdueBills().get(0).getDueDate().before(result.getOverdueBills().get(result.getOverdueBills().size() - 1).getDueDate()));
    }

    // Handles a single bill type filter efficiently
    @Test
    public void test_handles_single_bill_type_filter() {
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.PAID);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 10;
        int minDaysForNudge = 5;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountsByType result = billCoreServiceImpl.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        assertNotNull(result.getPaidBills());
    }

    // Handles null or empty bill types list gracefully
    @Test
    public void test_handles_null_or_empty_bill_types_list_gracefully() {
        // Prepare
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = null;
        int dueBillsDaysLimit = 10;
        int maxDaysForNudge = 5;
        int minDaysForNudge = 2;
        Pageable pageable = PageRequest.of(0, 10);

        // Execute
        CustomerBillAccountsByType result = code_under_test.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        // Verify
        assertNotNull(result);
        assertTrue(result.getOverdueBills().isEmpty());
        assertTrue(result.getDueBills().isEmpty());
        assertTrue(result.getPaidBills().isEmpty());
    }

    // Manages null or empty customer account ID without errors
    @Test
    public void test_manages_null_or_empty_customer_account_id_without_errors() {
        // Prepare
        UUID customerAccountId = null;
        List<BillType> billTypes = Collections.singletonList(BillType.ALL);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 5;
        int minDaysForNudge = 2;
        Pageable pageable = PageRequest.of(0, 10);

        // Perform
        CustomerBillAccountsByType result = billCoreService.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        // Verify
        assertNotNull(result);
        assertTrue(result.getOverdueBills().isEmpty());
        assertTrue(result.getDueBills().isEmpty());
        assertTrue(result.getPaidBills().isEmpty());
    }

    // Handles cases where due date is exactly today
    @Test
    public void test_handles_cases_where_due_date_is_exactly_today() {
        // Prepare
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Arrays.asList(BillType.DUE);
        int dueBillsDaysLimit = 7;
        int maxDaysForNudge = 3;
        int minDaysForNudge = 1;
        Pageable pageable = PageRequest.of(0, 10);

        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setDueDate(Date.from(LocalDate.now().atStartOfDay(ZoneId.systemDefault()).toInstant()));
        customerBillAccountDO.setDueInfoUpdatedAt(new Date());
        customerBillAccountDO.setLastPaidDateValue(new Date());
        customerBillAccountDO.setBillerDO(new BillerDO());
        CustomerBillAccount customerBillAccount = customerBillAccountMapper.customerBillAccountDOToCustomerBillAccount(customerBillAccountDO);

        when(customerBillAccountRepository.findAll(any(Predicate.class), eq(pageable))).thenReturn(new PageImpl<>(Collections.singletonList(customerBillAccountDO)));
        when(billReminderConfiguration.getDaysOfMonthForBillPaymentNudge()).thenReturn("1,15");
        when(billReminderConfiguration.getReminderDaysCountForBillpayNudge()).thenReturn(2);

        // Execute
        CustomerBillAccountsByType result = billCoreService.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        // Verify
        assertEquals(1, result.getDueBills().size());
    }

    // Processes accounts with no due date correctly
    @Test
    public void processes_accounts_with_no_due_date_correctly() {
        // Prepare
        UUID customerAccountId = UUID.randomUUID();
        List<BillType> billTypes = Collections.singletonList(BillType.ALL);
        int dueBillsDaysLimit = 30;
        int maxDaysForNudge = 5;
        int minDaysForNudge = 2;
        Pageable pageable = PageRequest.of(0, 10);

        // Mocking
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        customerBillAccountDO.setDueDate(null);
        customerBillAccountDO.setDueInfoUpdatedAt(new Date());
        customerBillAccountDO.setLastPaidDateValue(new Date());
        BillerDO billerDO = new BillerDO();
        customerBillAccountDO.setBillerDO(billerDO);
    
        List<CustomerBillAccountDO> customerBillAccountDOList = Collections.singletonList(customerBillAccountDO);
        Page<CustomerBillAccountDO> customerBillAccountDOPage = new PageImpl<>(customerBillAccountDOList);

        when(customerBillAccountRepository.findAll(any(Predicate.class), eq(pageable))).thenReturn(customerBillAccountDOPage);
    
        // Execution
        CustomerBillAccountsByType result = code_under_test.getCustomerBillAccountsByType(customerAccountId, billTypes, dueBillsDaysLimit, maxDaysForNudge, minDaysForNudge, pageable);

        // Verification
        assertTrue(result.getOverdueBills().isEmpty());
        assertTrue(result.getDueBills().isEmpty());
        assertFalse(result.getPaidBills().isEmpty());
    }

    // Processes accounts with future due dates accurately
    @Test
    public void processes_accounts_with_future_due_dates_accurately() {
        // Prepare test data
    
        // Call the method to test
    
        // Assert the results
    }

}
...............................................
import com.walmart.international.wallet.payment.core.service.BillCoreServiceImpl;

// Generated by Qodo Gen

import org.junit.Test;
import static org.junit.Assert.*;

public class CodeUnderTestTest {
    // Retrieve all saved customer bill accounts when valid billerId and customerAccountId are provided
    @Test
    public void test_retrieve_all_saved_customer_bill_accounts() {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        List<CustomerBillAccountDO> mockList = Arrays.asList(new CustomerBillAccountDO(), new CustomerBillAccountDO());
        BillerDO billerDO = new BillerDO();
        billerDO.setEnabled(true);
        when(billerRepository.getByBillerIdAndEnabled(billerId, true)).thenReturn(Optional.of(billerDO));
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), eq(customerAccountId)))
            .thenReturn(mockList);
        List<CustomerBillAccount> result = billCoreService.getSavedCustomerBillAccounts(billerId, customerAccountId, null);
        assertEquals(2, result.size());
    }

    // Retrieve saved customer bill accounts for a specific account number when provided
    @Test
    public void test_retrieve_saved_customer_bill_accounts_for_specific_account_number() {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456";
        List<CustomerBillAccountDO> mockList = Arrays.asList(new CustomerBillAccountDO());
        BillerDO billerDO = new BillerDO();
        billerDO.setEnabled(true);
        when(billerRepository.getByBillerIdAndEnabled(billerId, true)).thenReturn(Optional.of(billerDO));
        when(customerBillAccountRepository.findByBillerDOInAndAccountNumberAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), eq(accountNumber), eq(customerAccountId)))
            .thenReturn(mockList);
        List<CustomerBillAccount> result = billCoreService.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        assertEquals(1, result.size());
    }

    // Successfully map CustomerBillAccountDO to CustomerBillAccount using the mapper
    @Test
    public void test_map_customer_bill_account_do_to_customer_bill_account() {
        CustomerBillAccountDO customerBillAccountDO = new CustomerBillAccountDO();
        CustomerBillAccount customerBillAccount = new CustomerBillAccount();
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(customerBillAccountDO)).thenReturn(customerBillAccount);
        CustomerBillAccount result = customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(customerBillAccountDO);
        assertNotNull(result);
    }

    // Fetch biller information from the database using a valid billerId
    @Test
    public void test_fetch_biller_information_with_valid_biller_id() {
        UUID billerId = UUID.randomUUID();
        BillerDO billerDO = new BillerDO();
        when(billerRepository.getByBillerIdAndEnabled(billerId, true)).thenReturn(Optional.of(billerDO));
        BillerDO result = billCoreService.getBillerDOFromBillerId(billerId);
        assertNotNull(result);
    }

    // Handle sub-billers correctly when they exist and are enabled
    @Test
    public void test_handle_sub_billers_when_exist_and_enabled() {
        BillerDO mainBiller = new BillerDO();
        BillerDO subBiller = new BillerDO();
        subBiller.setEnabled(true);
        mainBiller.setSubBillers(Arrays.asList(subBiller));
        List<BillerDO> result = billCoreService.getBillerDOsOfSubBillersIfExist(mainBiller);
        assertEquals(1, result.size());
    }

    // Handle null billerId by throwing a DataValidationException
    @Test
    public void test_handle_null_biller_id_throws_exception() {
        UUID customerAccountId = UUID.randomUUID();
        assertThrows(DataValidationException.class, () -> {
            billCoreService.getSavedCustomerBillAccounts(null, customerAccountId, null);
        });
    }

    // Handle database exceptions by throwing a ProcessingException with appropriate error message
    @Test
    public void test_handle_database_exceptions() {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456789";
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenThrow(new RuntimeException("Database connection error"));
    
        CodeUnderTest code_under_test = new CodeUnderTest();
    
        assertThrows(ProcessingException.class, () -> {
            code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        });
    }

    // Handle empty list of enabled sub-billers by throwing a BusinessValidationException
    @Test
    public void test_handle_empty_list_of_enabled_sub_billers() {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456789";
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.of(new BillerDO()));
        when(billerRepository.getByProcessorBillerIdAndEnabled(anyString(), anyBoolean())).thenReturn(Optional.of(new BillerDO()));
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), any(UUID.class)))
                .thenReturn(Collections.emptyList());
    
        CodeUnderTest code_under_test = new CodeUnderTest(billerRepository, customerBillAccountRepository);
    
        assertThrows(BusinessValidationException.class, () -> {
            code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        });
    }

    // Ensure that the method logs appropriate messages at each step for debugging
    @Test
    public void test_get_saved_customer_bill_accounts_logs_messages() {
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456789";
    
        // Mocking behavior
        BillerDO billerDO = new BillerDO();
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.of(billerDO));
    
        List<BillerDO> billerDOList = new ArrayList<>();
        billerDOList.add(billerDO);
        when(getBillerDOsOfSubBillersIfExist(any(BillerDO.class))).thenReturn(billerDOList);
    
        List<CustomerBillAccountDO> customerBillAccountDOList = new ArrayList<>();
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), any(UUID.class)))
                .thenReturn(customerBillAccountDOList);
    
        // Call the method
        try {
            code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        } catch (Exception e) {
            // Ignore exception for testing logging messages
        }
    
        // Verify log messages
        verify(log, times(2)).info(anyString());
        verify(log, times(1)).error(anyString(), any(Exception.class));
    }

    // Validate that the method throws a BusinessValidationException when no enabled billers are found
    @Test
    public void test_throws_exception_when_no_enabled_billers_found() {
        // Arrange
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456";
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.empty());
    
        // Act & Assert
        assertThrows(BusinessValidationException.class, () -> {
            code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        });
    }

    // Verify that the method returns an empty list when no saved customer bill accounts are found
    @Test
    public void test_returns_empty_list_when_no_saved_customer_bill_accounts_found() {
        // Arrange
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456";
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.of(new BillerDO()));
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), any(UUID.class)))
                .thenReturn(Collections.emptyList());
    
        // Act
        List<CustomerBillAccount> result = code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
    
        // Assert
        assertTrue(result.isEmpty());
    }
    @Test
    public void test_returns_empty_list_when_no_saved_customer_bill_accounts_found_with_null_billerId() {
        // Arrange
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456";
    
        // Act
        DataValidationException exception = assertThrows(DataValidationException.class, () -> {
            code_under_test.getSavedCustomerBillAccounts(null, customerAccountId, accountNumber);
        });
    
        // Assert
        assertEquals(ErrorConstants.GetSavedCustomerBillAccounts.BILLER_ID_IS_NULL, exception.getMessage());
    }
    @Test
    public void test_returns_empty_list_when_no_saved_customer_bill_accounts_found_with_no_enabled_billers() {
        // Arrange
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456";
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.of(new BillerDO()));
        when(getBillerDOsOfSubBillersIfExist(any(BillerDO.class))).thenReturn(Collections.emptyList());
    
        // Act
        BusinessValidationException exception = assertThrows(BusinessValidationException.class, () -> {
            code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
        });
    
        // Assert
        assertEquals(ErrorConstants.GetSavedCustomerBillAccounts.NO_ENABLED_BILLERS_FOUND, exception.getMessage());
    }

    // Ensure that the method handles duplicate customer bill accounts correctly by de-duping them
    @Test
    public void test_handles_duplicate_customer_bill_accounts_correctly() {
        // Prepare
        UUID billerId = UUID.randomUUID();
        UUID customerAccountId = UUID.randomUUID();
        String accountNumber = "123456789";
    
        BillerDO billerDO = new BillerDO();
        billerDO.setBillerId(billerId);
    
        List<BillerDO> billerDOList = new ArrayList<>();
        billerDOList.add(billerDO);
    
        when(billerRepository.getByBillerIdAndEnabled(any(UUID.class), anyBoolean())).thenReturn(Optional.of(billerDO));
        when(customerBillAccountRepository.findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), any(UUID.class)))
                .thenReturn(Collections.singletonList(new CustomerBillAccountDO()));
        when(customerBillAccountMapper.customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class)))
                .thenReturn(new CustomerBillAccount());
    
        // Execute
        List<CustomerBillAccount> result = code_under_test.getSavedCustomerBillAccounts(billerId, customerAccountId, accountNumber);
    
        // Verify
        assertNotNull(result);
        assertFalse(result.isEmpty());
    
        verify(billerRepository, times(1)).getByBillerIdAndEnabled(any(UUID.class), anyBoolean());
        verify(customerBillAccountRepository, times(1)).findByBillerDOInAndIsSavedTrueAndIsDeletedFalseAndCustomerAccountIdOrderByLastPaidDateDesc(anyList(), any(UUID.class));
        verify(customerBillAccountMapper, times(1)).customerBillAccountDOToCustomerBillAccountWithBiller(any(CustomerBillAccountDO.class));
    }

}
...............................................
...............................................
This Java method, `processCancelBillPaymentInitEvent`, appears to handle the cancellation of a bill payment transaction. Here's a breakdown of what each part of the code does:

1. **Method Signature**: 
   - `@Override` indicates that this method overrides a method declared in a superclass or interface.
   - `public void processCancelBillPaymentInitEvent(PayBillInitEventPayload payBillInitEventPayload)` is the method declaration. It takes a single parameter of type `PayBillInitEventPayload`.

2. **Extracting Context**:
   - `BillPayTxnResponseDomainContext billPayTxnResponseDomainContext = payBillInitEventPayload.getBillPayTxnResponseDomainContext();`
     - This line retrieves the `BillPayTxnResponseDomainContext` from the `payBillInitEventPayload`. This context likely contains information about the transaction that needs to be canceled.

3. **Retrieving Transaction Objects**:
   - `CoFTopupTransactionDO coFTopupTransactionDO = billPayTxnResponseDomainContext.getCoFTopupTransactionDO();`
     - Retrieves a `CoFTopupTransactionDO` object, which might represent a top-up transaction related to the bill payment.
   - `BillPayTransactionDO billPayTransactionDO = billPayTxnResponseDomainContext.getBillPayTransactionDO();`
     - Retrieves a `BillPayTransactionDO` object, representing the bill payment transaction data object.
   - `BillPayTransaction billPayTransaction = billPayTxnResponseDomainContext.getTransaction();`
     - Retrieves a `BillPayTransaction` object, which might be a more comprehensive representation of the transaction.

4. **Processing Cancellations**:
   - `cancelCoFTopupCoreTransaction(coFTopupTransactionDO);`
     - Calls a method to cancel the core transaction related to the top-up.
   - `updateCoFTopupTransaction(coFTopupTransactionDO, billPayTransaction);`
     - Updates the top-up transaction, possibly to reflect its canceled status.
   - `cancelBillPayCoreTransactionRequest(billPayTransactionDO);`
     - Cancels the core transaction request for the bill payment.
   - `updateBillPayTransaction(billPayTxnResponseDomainContext);`
     - Updates the bill payment transaction, likely to reflect the cancellation.

Overall, this method is responsible for handling the cancellation process of a bill payment, including any associated top-up transactions. It retrieves necessary transaction data from the payload, performs cancellation operations, and updates the transaction records accordingly.
...............................................
This Java method, `updateBillPayTransactionStateForReversal`, is designed to update the state of a bill payment transaction in a database, specifically for reversal purposes. Here's a breakdown of what the code does:

1. **Method Signature**: 
   - The method is annotated with `@Override`, indicating it overrides a method in a superclass or implements a method from an interface.
   - It takes two parameters: 
     - `UUID transactionId`: A unique identifier for the transaction.
     - `BillPayTxnStateReason billPayTxnStateReason`: An object representing the reason for the transaction's state change.

2. **Try-Catch Block**: 
   - The method uses a try-catch block to handle potential exceptions that might occur during the database operations.

3. **Finding the Transaction**:
   - It attempts to retrieve a `BillPayTransactionDO` object from the `billPayTransactionRepository` using the `transactionId`.
   - The result is wrapped in an `Optional`, which is a container object that may or may not contain a non-null value.

4. **Updating the Transaction**:
   - If the transaction is found (`billPayTransactionDOOptional.isPresent()` returns `true`), it retrieves the transaction object.
   - It then updates the transaction's state reason with the provided `billPayTxnStateReason`.
   - The updated transaction is saved back to the repository.

5. **Logging**:
   - If the transaction is not found, it logs an error message indicating that the transaction does not exist and therefore cannot be updated.
   - If an exception occurs during the process, it logs an error message with the exception details.

This method is part of a larger system that manages bill payment transactions, likely within a financial or banking application. The use of logging and exception handling suggests a focus on robustness and error tracking.
...............................................
This Java method, `cancelCoFTopupCoreTransaction`, is designed to handle the cancellation of a CoF (Card on File) top-up transaction. Here's a breakdown of what the code does:

1. **Method Signature**: 
   - The method is `private`, meaning it can only be accessed within the class it is defined in.
   - It takes a single parameter, `CoFTopupTransactionDO coFTopupTransactionDO`, which is presumably a data object representing the transaction to be canceled.
   - It throws a `ProcessingException`, indicating that this exception might be thrown during the method's execution.

2. **Transaction ID Extraction**:
   - The method retrieves the transaction ID from the `coFTopupTransactionDO` object using `getCoFTopupTransactionId()` and stores it in a `UUID` variable named `transactionId`.

3. **Logging**:
   - It logs an informational message indicating that a cancellation request is being made for the specified transaction ID.

4. **Cancellation Request**:
   - A `CancelRequest` object is constructed using a builder pattern. It includes:
     - `clientTransactionId`: A string composed of the transaction ID and a suffix "1", joined by an underscore.
     - `clientTransactionUUID`: The transaction ID itself.

5. **Cancellation Execution**:
   - The `paymentCoreService.cancel(cancelRequest)` method is called to execute the cancellation request, and the response is stored in a `CancelResponse` object.

6. **Response Handling**:
   - The method checks if the cancellation status is not `CANCELLED`. If the cancellation fails (i.e., the status is not `CANCELLED`), it constructs an error message and throws a `BusinessValidationException` with a specific error constant and the message.

7. **Exception Handling**:
   - If a `PaymentCoreServiceException` is thrown during the cancellation process, the method catches it, logs an error message, and throws a `ProcessingException` with a specific error constant, the message, and the original exception.

Overall, this method is responsible for managing the cancellation of a CoF top-up transaction, handling both successful and failed cancellation attempts, and ensuring that any issues are properly logged and reported through exceptions.
...............................................
This Java method, `cancelBillPayCoreTransactionRequest`, is designed to cancel a bill payment transaction using a service called `paymentCoreService`. Here's a breakdown of what each part of the code does:

1. **Extract Transaction ID**: 
   - The method takes a `BillPayTransactionDO` object as a parameter and extracts the transaction ID from it, converting it to a string.

2. **Logging**:
   - It logs an informational message indicating that it is calling the PaymentCore service to cancel a transaction with the specified transaction ID.

3. **Create Cancel Request**:
   - A `CancelRequest` object is created using a builder pattern. It sets the `clientTransactionId` and `clientTransactionUUID` using the transaction ID from the `BillPayTransactionDO` object.

4. **Call PaymentCore Service**:
   - The `cancelPayRequest` method of `paymentCoreService` is called with the `CancelRequest` object. This method presumably interacts with an external service to attempt to cancel the transaction.

5. **Check Response Status**:
   - The response from the service call is checked. If the status of the response is not `CANCELLED`, it constructs an error message and throws a `BusinessValidationException`. This indicates that the cancellation attempt failed.

6. **Exception Handling**:
   - If a `PaymentCoreServiceException` is thrown during the service call, it catches this exception, constructs an error message, and throws a `ProcessingException`. This suggests that there was an issue processing the cancellation request.

Overall, this method is responsible for handling the cancellation of a bill payment transaction, including logging, making a service call, and handling any errors that occur during the process.
...............................................
This Java method, `updateCoFTopupTransaction`, is designed to update a `CoFTopupTransactionDO` object based on the state of a `BillPayTransaction`. Here's a breakdown of what each part of the method does:

1. **Set State Reason and State**: 
   - `coFTopupTransactionDO.setStateReason(CoFTopupTxnStateReason.DEBIT_FAILED);` sets the state reason of the `CoFTopupTransactionDO` to `DEBIT_FAILED`.
   - `coFTopupTransactionDO.setState(TransactionStateEnum.FAILURE);` sets the transaction state to `FAILURE`.

2. **Set Abort Reason**:
   - `coFTopupTransactionDO.setAbortReason(billPayTransaction.getAbortReason());` assigns the abort reason from the `BillPayTransaction` to the `CoFTopupTransactionDO`.

3. **Update Last Event Date**:
   - `coFTopupTransactionDO.updateLastEventDate();` updates the last event date of the transaction, likely to the current date and time.

4. **Logging**:
   - `log.info(...)` logs an informational message indicating that the `CoFTopupTransactionDO` is being updated due to a cancelled `BillPayTransaction`. It includes the transaction IDs for traceability.

5. **Save Transaction**:
   - `coFTopupTransactionDO = coFTopupTransactionRepository.save(coFTopupTransactionDO);` saves the updated `CoFTopupTransactionDO` back to the repository, which typically means persisting the changes to a database.

6. **Publish Event**:
   - `eventHelper.publishAsync(...)` publishes an asynchronous event indicating that the transaction has been completed. This event is sent to a downstream service, `TXN_AGGREGATER_SERVICE`, which might be responsible for aggregating transaction data.

Overall, this method handles the failure of a bill payment transaction by updating the corresponding top-up transaction's state and notifying other system components of the change.
...............................................
This Java method, `updateBillPayTransaction`, is designed to update the state of a bill payment transaction when a specific event occurs, such as a cancellation. Here's a breakdown of what each part of the code does:

1. **Retrieve Transaction Objects**: 
   - `BillPayTransactionDO billPayTransactionDO = billPayTxnResponseDomainContext.getBillPayTransactionDO();` 
   - `BillPayTransaction billPayTransaction = billPayTxnResponseDomainContext.getTransaction();`
   These lines extract the `BillPayTransactionDO` and `BillPayTransaction` objects from the `billPayTxnResponseDomainContext`. These objects represent the data and state of the bill payment transaction.

2. **Set Transaction State**:
   - `billPayTransactionDO.setState(TransactionStateEnum.FAILURE);`
   - `billPayTransactionDO.setStateReason(BillPayTxnStateReason.TOPUP_3DS_CANCELLED);`
   - `billPayTransactionDO.setAbortReason(billPayTransaction.getAbortReason());`
   These lines update the transaction's state to `FAILURE`, set the reason for this state to `TOPUP_3DS_CANCELLED`, and record the abort reason from the `billPayTransaction`.

3. **Update Event Date**:
   - `billPayTransactionDO.updateLastEventDate();`
   This updates the last event date for the transaction, likely to the current date and time.

4. **Log Information**:
   - `log.info("Updating billPay transaction for cancelled bill pay Transaction, transactionId : {}", billPayTransactionDO.getBillPayTransactionId());`
   This logs an informational message indicating that the transaction is being updated, including the transaction ID.

5. **Persist Changes**:
   - `billPayTransactionDO = billPayTransactionRepository.save(billPayTransactionDO);`
   This saves the updated transaction object back to the database or repository.

6. **Synchronize Transaction**:
   - `txnAggregatorServiceAdapter.syncBillPayTransaction(billPayTransactionDO);`
   This line likely synchronizes the transaction with an external service or system, ensuring that all systems have the updated transaction state.

7. **Fetch Lazy Loaded Data**:
   - `billPayTransactionDO.getBillDetailDO();`
   This is used to fetch the `BillDetailDO` object, which is lazily loaded. This ensures that the data is loaded before the session is closed, which might happen in the `CancelBillPaymentInitiatedListener`.

8. **Publish Event**:
   - `eventHelper.publishAsync(billPayTransactionDO.getBillPayTransactionId().toString(), billPayTransactionDO, WalletEventType.TXN_COMPLETED, List.of(EventDownstream.TXN_AGGREGATER_SERVICE));`
   This publishes an asynchronous event indicating that the transaction has been completed, sending it to a list of downstream services, in this case, the `TXN_AGGREGATER_SERVICE`.

Overall, this method handles the transition of a bill payment transaction to a failed state due to a cancellation, updates the necessary records, synchronizes with external systems, and publishes an event to notify other components of the system.
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
...............................................
